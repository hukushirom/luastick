// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8455)
// Generated by LuaStick, May 26 2021.

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8463)
#include "stdafx.h"
// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8463)
#include "..\..\LuaStick\files\Sticklib.h"
// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8463)
#include "TestClass.h"
// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8463)
#include "StickClassExample.h"
// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8471)
#include "Stick.h"

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5750)
/// <summary>
/// Gets ::TestStruct0 value from Lua stack.
/// </summary>
template<>
void Sticklib::check_lvalue<::TestStruct0>(::TestStruct0 & value, lua_State * L, int arg)
{
	//        stack
	//     :          :
	//     |----------|
	//  arg| table A  |--------------+
	//     |----------|              |
	//     :          :              V
	//                       +--------+--------+
	//                       |  Key   | Value  |
	//                       |--------|--------|
	//                       :        :        :
	//                       |--------|--------|
	//                       | "var1" | value1 |
	//                       |--------|--------|
	//                       :        :        :
	// Premise for following.
	//
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5599)
		//
		// lua_getfield(L, arg, "var1");
		//
		//        stack
		//     +----------+
		//   -1|  value1  |
		//     |----------|
		//     :          :
		//     |----------|
		//     | table A  |--------------+
		//     |----------|              |
		//     :          :              V
		//                       +--------+--------+
		//                       |  Key   | Value  |
		//                       |--------|--------|
		//                       :        :        :
		//                       |--------|--------|
		//                       | "var1" | value1 | ----> Push this value on stack
		//                       |--------|--------|
		//                       :        :        :
		//
		lua_getfield(L, arg, "m_a");

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5650)
		//
		// Sticklib::check_lvalue<__int64>(_argin_1, L, -1);
		//
		//        stack
		//     +----------+
		//   -1|  value1  | ---> Set this value to '_argin_1'
		//     |----------|
		//     :          :
		//     |----------|
		//     | table A  |
		//     |----------|
		//     :          :
		//
		__int64 _argin_1;
		Sticklib::check_lvalue<__int64>(_argin_1, L, -1);

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5672)
		Sticklib::T_to_U(value.m_a, _argin_1);

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5716)
		//
		// lua_pop(L, 1);
		//
		//        stack
		//     :          :
		//     |----------|
		//  arg| table A  |
		//     |----------|
		//     :          :
		//
		lua_pop(L, 1);
	}
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5599)
		//
		// lua_getfield(L, arg, "var1");
		//
		//        stack
		//     +----------+
		//   -1|  value1  |
		//     |----------|
		//     :          :
		//     |----------|
		//     | table A  |--------------+
		//     |----------|              |
		//     :          :              V
		//                       +--------+--------+
		//                       |  Key   | Value  |
		//                       |--------|--------|
		//                       :        :        :
		//                       |--------|--------|
		//                       | "var1" | value1 | ----> Push this value on stack
		//                       |--------|--------|
		//                       :        :        :
		//
		lua_getfield(L, arg, "m_b");

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5650)
		//
		// Sticklib::check_lvalue<std::string>(_argin_1, L, -1);
		//
		//        stack
		//     +----------+
		//   -1|  value1  | ---> Set this value to '_argin_1'
		//     |----------|
		//     :          :
		//     |----------|
		//     | table A  |
		//     |----------|
		//     :          :
		//
		std::string _argin_1;
		Sticklib::check_lvalue<std::string>(_argin_1, L, -1);

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5672)
		Sticklib::astring_to_wstring(value.m_b, _argin_1);

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5716)
		//
		// lua_pop(L, 1);
		//
		//        stack
		//     :          :
		//     |----------|
		//  arg| table A  |
		//     |----------|
		//     :          :
		//
		lua_pop(L, 1);
	}
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5599)
		//
		// lua_getfield(L, arg, "var1");
		//
		//        stack
		//     +----------+
		//   -1|  value1  |
		//     |----------|
		//     :          :
		//     |----------|
		//     | table A  |--------------+
		//     |----------|              |
		//     :          :              V
		//                       +--------+--------+
		//                       |  Key   | Value  |
		//                       |--------|--------|
		//                       :        :        :
		//                       |--------|--------|
		//                       | "var1" | value1 | ----> Push this value on stack
		//                       |--------|--------|
		//                       :        :        :
		//
		lua_getfield(L, arg, "m_x");

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5650)
		//
		// Sticklib::check_array<__int64>(_argin_1, L, -1);
		//
		//        stack
		//     +----------+
		//   -1|  value1  | ---> Set this value to '_argin_1'
		//     |----------|
		//     :          :
		//     |----------|
		//     | table A  |
		//     |----------|
		//     :          :
		//
		std::vector<__int64> _argin_1;
		Sticklib::check_array<__int64>(_argin_1, L, -1);

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5672)
		Sticklib::vector_to_vector<int,__int64>(value.m_x, _argin_1);

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5716)
		//
		// lua_pop(L, 1);
		//
		//        stack
		//     :          :
		//     |----------|
		//  arg| table A  |
		//     |----------|
		//     :          :
		//
		lua_pop(L, 1);
	}
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5599)
		//
		// lua_getfield(L, arg, "var1");
		//
		//        stack
		//     +----------+
		//   -1|  value1  |
		//     |----------|
		//     :          :
		//     |----------|
		//     | table A  |--------------+
		//     |----------|              |
		//     :          :              V
		//                       +--------+--------+
		//                       |  Key   | Value  |
		//                       |--------|--------|
		//                       :        :        :
		//                       |--------|--------|
		//                       | "var1" | value1 | ----> Push this value on stack
		//                       |--------|--------|
		//                       :        :        :
		//
		lua_getfield(L, arg, "x");

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5625)
		//
		// Sticklib::check_lvalue<double>(value.x, L, -1);
		//
		//        stack
		//     +----------+
		//   -1|  value1  | ---> Set this value to 'value.x'
		//     |----------|
		//     :          :
		//     |----------|
		//     | table A  |
		//     |----------|
		//     :          :
		//
		Sticklib::check_lvalue<double>(value.x, L, -1);

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5716)
		//
		// lua_pop(L, 1);
		//
		//        stack
		//     :          :
		//     |----------|
		//  arg| table A  |
		//     |----------|
		//     :          :
		//
		lua_pop(L, 1);
	}
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5750)
/// <summary>
/// Gets ::TestStruct1 value from Lua stack.
/// </summary>
template<>
void Sticklib::check_lvalue<::TestStruct1>(::TestStruct1 & value, lua_State * L, int arg)
{
	//        stack
	//     :          :
	//     |----------|
	//  arg| table A  |--------------+
	//     |----------|              |
	//     :          :              V
	//                       +--------+--------+
	//                       |  Key   | Value  |
	//                       |--------|--------|
	//                       :        :        :
	//                       |--------|--------|
	//                       | "var1" | value1 |
	//                       |--------|--------|
	//                       :        :        :
	// Premise for following.
	//
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5599)
		//
		// lua_getfield(L, arg, "var1");
		//
		//        stack
		//     +----------+
		//   -1|  value1  |
		//     |----------|
		//     :          :
		//     |----------|
		//     | table A  |--------------+
		//     |----------|              |
		//     :          :              V
		//                       +--------+--------+
		//                       |  Key   | Value  |
		//                       |--------|--------|
		//                       :        :        :
		//                       |--------|--------|
		//                       | "var1" | value1 | ----> Push this value on stack
		//                       |--------|--------|
		//                       :        :        :
		//
		lua_getfield(L, arg, "m_c");

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5625)
		//
		// Sticklib::check_lvalue<::TestStruct0>(value.m_c, L, -1);
		//
		//        stack
		//     +----------+
		//   -1|  value1  | ---> Set this value to 'value.m_c'
		//     |----------|
		//     :          :
		//     |----------|
		//     | table A  |
		//     |----------|
		//     :          :
		//
		Sticklib::check_lvalue<::TestStruct0>(value.m_c, L, -1);

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5716)
		//
		// lua_pop(L, 1);
		//
		//        stack
		//     :          :
		//     |----------|
		//  arg| table A  |
		//     |----------|
		//     :          :
		//
		lua_pop(L, 1);
	}
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5599)
		//
		// lua_getfield(L, arg, "var1");
		//
		//        stack
		//     +----------+
		//   -1|  value1  |
		//     |----------|
		//     :          :
		//     |----------|
		//     | table A  |--------------+
		//     |----------|              |
		//     :          :              V
		//                       +--------+--------+
		//                       |  Key   | Value  |
		//                       |--------|--------|
		//                       :        :        :
		//                       |--------|--------|
		//                       | "var1" | value1 | ----> Push this value on stack
		//                       |--------|--------|
		//                       :        :        :
		//
		lua_getfield(L, arg, "m_d");

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5650)
		//
		// Sticklib::check_lvalue<::TestClass0*>(_argin_1, L, -1);
		//
		//        stack
		//     +----------+
		//   -1|  value1  | ---> Set this value to '_argin_1'
		//     |----------|
		//     :          :
		//     |----------|
		//     | table A  |
		//     |----------|
		//     :          :
		//
		::TestClass0* _argin_1;
		Sticklib::check_lvalue<::TestClass0*>(_argin_1, L, -1);

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5664)
		value.m_d = *_argin_1;

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5716)
		//
		// lua_pop(L, 1);
		//
		//        stack
		//     :          :
		//     |----------|
		//  arg| table A  |
		//     |----------|
		//     :          :
		//
		lua_pop(L, 1);
	}
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5974)
/// <summary>
/// Pushes ::TestStruct0 value on Lua stack.
/// </summary>
template<>
void Sticklib::push_lvalue<::TestStruct0>(lua_State * L, ::TestStruct0 const & value, bool own)
{
	//        stack
	//     :          :
	//     |          | 
	//     :          : 
	//                  
	// Premise for following.
	//

	// lua_newtable(L);
	//
	//        stack
	//     +----------+      +---------+---------+
	//   -1|  TABLE   |----->| Key     | Value   |
	//     |----------|      +---------+---------+
	//     :          : 
	//
	lua_newtable(L);
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5785)
		int& _var_1 = (int&)value.m_a;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5808)
		__int64 _var_2;
		Sticklib::T_to_U(_var_2, _var_1);

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5936)
		//
		// Sticklib::push_lvalue<__int64>(L, value);
		//
		//        stack  
		//     +----------+
		//   -1|  value   |
		//     +----------+      +---------+---------+
		//   -2|  TABLE   |----->| Key     | Value   |
		//     |----------|      +---------+---------+
		//     :          :
		//
		Sticklib::push_lvalue<__int64>(L, _var_2, false);

		// lua_setfield(L, -2, "var1");
		//
		//        stack  
		//     +----------+      +---------+---------+
		//   -1|  TABLE   |----->| Key     | Value   |
		//     |----------|      +---------+---------+
		//     :          :      | "var1"  |  value  |
		//                       +---------+---------+
		//
		lua_setfield(L, -2, "m_a");
	}
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5785)
		std::wstring& _var_1 = (std::wstring&)value.m_b;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5808)
		std::string _var_2;
		Sticklib::wstring_to_astring(_var_2, _var_1);

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5936)
		//
		// Sticklib::push_lvalue<std::string>(L, value);
		//
		//        stack  
		//     +----------+
		//   -1|  value   |
		//     +----------+      +---------+---------+
		//   -2|  TABLE   |----->| Key     | Value   |
		//     |----------|      +---------+---------+
		//     :          :
		//
		Sticklib::push_lvalue<std::string>(L, _var_2, false);

		// lua_setfield(L, -2, "var1");
		//
		//        stack  
		//     +----------+      +---------+---------+
		//   -1|  TABLE   |----->| Key     | Value   |
		//     |----------|      +---------+---------+
		//     :          :      | "var1"  |  value  |
		//                       +---------+---------+
		//
		lua_setfield(L, -2, "m_b");
	}
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5785)
		std::vector<int>& _var_1 = (std::vector<int>&)value.m_x;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5808)
		std::vector<__int64> _var_2;
		Sticklib::vector_to_vector<__int64,int>(_var_2, _var_1);

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5936)
		//
		// Sticklib::push_array<__int64>(L, value);
		//
		//        stack  
		//     +----------+
		//   -1|  value   |
		//     +----------+      +---------+---------+
		//   -2|  TABLE   |----->| Key     | Value   |
		//     |----------|      +---------+---------+
		//     :          :
		//
		Sticklib::push_array<__int64>(L, _var_2, false);

		// lua_setfield(L, -2, "var1");
		//
		//        stack  
		//     +----------+      +---------+---------+
		//   -1|  TABLE   |----->| Key     | Value   |
		//     |----------|      +---------+---------+
		//     :          :      | "var1"  |  value  |
		//                       +---------+---------+
		//
		lua_setfield(L, -2, "m_x");
	}
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5785)
		double& _var_1 = (double&)value.x;

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5936)
		//
		// Sticklib::push_lvalue<double>(L, value);
		//
		//        stack  
		//     +----------+
		//   -1|  value   |
		//     +----------+      +---------+---------+
		//   -2|  TABLE   |----->| Key     | Value   |
		//     |----------|      +---------+---------+
		//     :          :
		//
		Sticklib::push_lvalue<double>(L, _var_1, false);

		// lua_setfield(L, -2, "var1");
		//
		//        stack  
		//     +----------+      +---------+---------+
		//   -1|  TABLE   |----->| Key     | Value   |
		//     |----------|      +---------+---------+
		//     :          :      | "var1"  |  value  |
		//                       +---------+---------+
		//
		lua_setfield(L, -2, "x");
	}
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5974)
/// <summary>
/// Pushes ::TestStruct1 value on Lua stack.
/// </summary>
template<>
void Sticklib::push_lvalue<::TestStruct1>(lua_State * L, ::TestStruct1 const & value, bool own)
{
	//        stack
	//     :          :
	//     |          | 
	//     :          : 
	//                  
	// Premise for following.
	//

	// lua_newtable(L);
	//
	//        stack
	//     +----------+      +---------+---------+
	//   -1|  TABLE   |----->| Key     | Value   |
	//     |----------|      +---------+---------+
	//     :          : 
	//
	lua_newtable(L);
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5785)
		::TestStruct0& _var_1 = (::TestStruct0&)value.m_c;

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5936)
		//
		// Sticklib::push_lvalue<::TestStruct0>(L, value);
		//
		//        stack  
		//     +----------+
		//   -1|  value   |
		//     +----------+      +---------+---------+
		//   -2|  TABLE   |----->| Key     | Value   |
		//     |----------|      +---------+---------+
		//     :          :
		//
		Sticklib::push_lvalue<::TestStruct0>(L, _var_1, false);

		// lua_setfield(L, -2, "var1");
		//
		//        stack  
		//     +----------+      +---------+---------+
		//   -1|  TABLE   |----->| Key     | Value   |
		//     |----------|      +---------+---------+
		//     :          :      | "var1"  |  value  |
		//                       +---------+---------+
		//
		lua_setfield(L, -2, "m_c");
	}
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5785)
		::TestClass0& _var_1 = (::TestClass0&)value.m_d;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5799)
		::TestClass0* _var_2 = &_var_1;

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5936)
		//
		// Sticklib::push_lvalue<::TestClass0*>(L, value);
		//
		//        stack  
		//     +----------+
		//   -1|  value   |
		//     +----------+      +---------+---------+
		//   -2|  TABLE   |----->| Key     | Value   |
		//     |----------|      +---------+---------+
		//     :          :
		//
		Sticklib::push_lvalue<::TestClass0*>(L, _var_2, false);

		// lua_setfield(L, -2, "var1");
		//
		//        stack  
		//     +----------+      +---------+---------+
		//   -1|  TABLE   |----->| Key     | Value   |
		//     |----------|      +---------+---------+
		//     :          :      | "var1"  |  value  |
		//                       +---------+---------+
		//
		lua_setfield(L, -2, "m_d");
	}
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6032)
/// <summary>
/// ::TestClass0::~TestClass0()
/// </summary>
static int lm__TestClass0__Destructor(lua_State* L)
{
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Get the class object.
		auto __wrapper = (StickInstanceWrapper*)Sticklib::test_classobject(L, 1, "lm__TestClass0__");
		if (__wrapper->own && __wrapper->ptr != nullptr)
		{
			delete (::TestClass0*)__wrapper->ptr;
			__wrapper->ptr = nullptr;
		}
	}
	catch (std::exception & e)
	{
		luaL_error(L, (std::string("C function error:::TestClass0::~TestClass0:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass0::~TestClass0");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6032)
/// <summary>
/// ::TestClass1::~TestClass1()
/// </summary>
static int lm__TestClass1__Destructor(lua_State* L)
{
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Get the class object.
		auto __wrapper = (StickInstanceWrapper*)Sticklib::test_classobject(L, 1, "lm__TestClass1__");
		if (__wrapper->own && __wrapper->ptr != nullptr)
		{
			delete (::TestClass1*)__wrapper->ptr;
			__wrapper->ptr = nullptr;
		}
	}
	catch (std::exception & e)
	{
		luaL_error(L, (std::string("C function error:::TestClass1::~TestClass1:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass1::~TestClass1");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6032)
/// <summary>
/// ::TestClass2::~TestClass2()
/// </summary>
static int lm__TestClass2__Destructor(lua_State* L)
{
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Get the class object.
		auto __wrapper = (StickInstanceWrapper*)Sticklib::test_classobject(L, 1, "lm__TestClass2__");
		if (__wrapper->own && __wrapper->ptr != nullptr)
		{
			delete (::TestClass2*)__wrapper->ptr;
			__wrapper->ptr = nullptr;
		}
	}
	catch (std::exception & e)
	{
		luaL_error(L, (std::string("C function error:::TestClass2::~TestClass2:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass2::~TestClass2");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4095)
/// <summary>
/// ::App()
/// </summary>
static int lm__App__0(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4127)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 0)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4437)
		// Call the c++ function.
		auto __lstickvar_ret = (::CStickClassExampleApp*)::App();
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4631)
		Sticklib::push_lvalue<::CStickClassExampleApp*>(L, __lstickvar_ret, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4713)
		luaL_error(L, (std::string("C function error:::App:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::App");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4095)
/// <summary>
/// ::TestSpace::GetA()
/// </summary>
static int lm__TestSpace__GetA__0(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4127)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 0)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4437)
		// Call the c++ function.
		auto __lstickvar_ret = (std::string)::TestSpace::GetA();
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4631)
		Sticklib::push_lvalue<std::string>(L, __lstickvar_ret, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4713)
		luaL_error(L, (std::string("C function error:::TestSpace::GetA:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestSpace::GetA");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4095)
/// <summary>
/// ::TestClassA::Get()
/// </summary>
static int lm__TestClassA__Get__0(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4127)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 0)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4437)
		// Call the c++ function.
		auto __lstickvar_ret = (int)::TestClassA::Get();
		__int64 _argout_0_1;
		Sticklib::T_to_U(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4631)
		Sticklib::push_lvalue<__int64>(L, _argout_0_1, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4713)
		luaL_error(L, (std::string("C function error:::TestClassA::Get:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClassA::Get");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4095)
/// <summary>
/// ::TestClass0::Get(::TestStruct0& test)
/// </summary>
static int lm__TestClass0__Get__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4127)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4253)
		// Get the class object.
		::TestClass0 * __lstickobj;
		Sticklib::check_lvalue<::TestClass0*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4299)
		::TestStruct0 test;
		Sticklib::check_lvalue<::TestStruct0>(test, L, 2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4393)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		__lstickobj->Get((::TestStruct0&)test);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4631)
		Sticklib::push_lvalue<::TestStruct0>(L, test, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4713)
		luaL_error(L, (std::string("C function error:::TestClass0::Get:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass0::Get");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4095)
/// <summary>
/// ::TestClass0::GetArray(std::vector<::TestStruct0>& test)
/// </summary>
static int lm__TestClass0__GetArray__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4127)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4253)
		// Get the class object.
		::TestClass0 * __lstickobj;
		Sticklib::check_lvalue<::TestClass0*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4299)
		std::vector<::TestStruct0> test;
		Sticklib::check_array<::TestStruct0>(test, L, 2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4393)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		__lstickobj->GetArray((std::vector<::TestStruct0>&)test);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4631)
		Sticklib::push_array<::TestStruct0>(L, test, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4713)
		luaL_error(L, (std::string("C function error:::TestClass0::GetArray:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass0::GetArray");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4095)
/// <summary>
/// ::TestClass0::GetEnumA(::TestClass0::EnumA& ea)
/// </summary>
static int lm__TestClass0__GetEnumA__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4127)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4253)
		// Get the class object.
		::TestClass0 * __lstickobj;
		Sticklib::check_lvalue<::TestClass0*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4299)
		__int64 _argin_1_1;
		Sticklib::check_lvalue<__int64>(_argin_1_1, L, 2);
		::TestClass0::EnumA ea;
		Sticklib::int64_to_enumT<::TestClass0::EnumA>(ea, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4393)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		__lstickobj->GetEnumA((::TestClass0::EnumA&)ea);
		__int64 _argout_1_1;
		Sticklib::enumT_to_int64<::TestClass0::EnumA>(_argout_1_1, ea);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4631)
		Sticklib::push_lvalue<__int64>(L, _argout_1_1, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4713)
		luaL_error(L, (std::string("C function error:::TestClass0::GetEnumA:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass0::GetEnumA");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4095)
/// <summary>
/// ::TestClass0::GetTitle()
/// </summary>
static int lm__TestClass0__GetTitle__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4127)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4253)
		// Get the class object.
		::TestClass0 * __lstickobj;
		Sticklib::check_lvalue<::TestClass0*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4410)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		auto __lstickvar_ret = (std::string&)__lstickobj->GetTitle();
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4631)
		Sticklib::push_lvalue<std::string>(L, __lstickvar_ret, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4713)
		luaL_error(L, (std::string("C function error:::TestClass0::GetTitle:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass0::GetTitle");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4095)
/// <summary>
/// ::TestClass0::GetX()
/// </summary>
static int lm__TestClass0__GetX__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4127)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4253)
		// Get the class object.
		::TestClass0 * __lstickobj;
		Sticklib::check_lvalue<::TestClass0*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4410)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		auto __lstickvar_ret = (int)__lstickobj->GetX();
		__int64 _argout_0_1;
		Sticklib::T_to_U(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4631)
		Sticklib::push_lvalue<__int64>(L, _argout_0_1, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4713)
		luaL_error(L, (std::string("C function error:::TestClass0::GetX:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass0::GetX");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4095)
/// <summary>
/// ::TestClass0::SetTitle(std::string& title)
/// </summary>
static int lm__TestClass0__SetTitle__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4127)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4253)
		// Get the class object.
		::TestClass0 * __lstickobj;
		Sticklib::check_lvalue<::TestClass0*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4299)
		std::string title;
		Sticklib::check_lvalue<std::string>(title, L, 2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4393)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		__lstickobj->SetTitle((const std::string&)title);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4713)
		luaL_error(L, (std::string("C function error:::TestClass0::SetTitle:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass0::SetTitle");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4095)
/// <summary>
/// ::TestClass0::Create0()
/// </summary>
static int lm__TestClass0__Create0__0(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4127)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 0)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4437)
		// Call the c++ function.
		auto __lstickvar_ret = (TC0*)::TestClass0::Create0();
		::TestClass0* _argout_0_1;
		Sticklib::T_to_U<TC0*,::TestClass0*>(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4631)
		Sticklib::push_lvalue<::TestClass0*>(L, _argout_0_1, true);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4713)
		luaL_error(L, (std::string("C function error:::TestClass0::Create0:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass0::Create0");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4095)
/// <summary>
/// ::TestClass0::TestClass0()
/// </summary>
static int lm__TestClass0__New__0(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4127)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 0)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4447)
		// Create the class object and give back it to lua.
		auto obj = new ::TestClass0();
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4477)
		Sticklib::push_lvalue<::TestClass0*>(L, obj, true);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4713)
		luaL_error(L, (std::string("C function error:::TestClass0::TestClass0:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass0::TestClass0");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4095)
/// <summary>
/// ::TestClass1::Get()
/// </summary>
static int lm__TestClass1__Get__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4127)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4253)
		// Get the class object.
		::TestClass1 * __lstickobj;
		Sticklib::check_lvalue<::TestClass1*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4410)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		auto __lstickvar_ret = (int)__lstickobj->Get();
		__int64 _argout_0_1;
		Sticklib::T_to_U(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4631)
		Sticklib::push_lvalue<__int64>(L, _argout_0_1, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4713)
		luaL_error(L, (std::string("C function error:::TestClass1::Get:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass1::Get");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4095)
/// <summary>
/// ::TestClass1::GetClass0Array(std::vector<::TestClass0*>& array)
/// </summary>
static int lm__TestClass1__GetClass0Array__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4127)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4253)
		// Get the class object.
		::TestClass1 * __lstickobj;
		Sticklib::check_lvalue<::TestClass1*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4375)
		std::vector<::TestClass0*> array;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4393)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		__lstickobj->GetClass0Array((std::vector<::TestClass0*>&)array);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4631)
		Sticklib::push_array<::TestClass0*>(L, array, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4713)
		luaL_error(L, (std::string("C function error:::TestClass1::GetClass0Array:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass1::GetClass0Array");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4095)
/// <summary>
/// ::TestClass1::GetX()
/// </summary>
static int lm__TestClass1__GetX__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4127)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4253)
		// Get the class object.
		::TestClass1 * __lstickobj;
		Sticklib::check_lvalue<::TestClass1*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4410)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		auto __lstickvar_ret = (int)__lstickobj->GetX();
		__int64 _argout_0_1;
		Sticklib::T_to_U(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4631)
		Sticklib::push_lvalue<__int64>(L, _argout_0_1, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4713)
		luaL_error(L, (std::string("C function error:::TestClass1::GetX:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass1::GetX");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4095)
/// <summary>
/// ::TestClass1::SetClass0Array(std::vector<::TestClass0*>& array)
/// </summary>
static int lm__TestClass1__SetClass0Array__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4127)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4253)
		// Get the class object.
		::TestClass1 * __lstickobj;
		Sticklib::check_lvalue<::TestClass1*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4299)
		std::vector<::TestClass0*> array;
		Sticklib::check_array<::TestClass0*>(array, L, 2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4393)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		__lstickobj->SetClass0Array((const std::vector<::TestClass0*>&)array);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4713)
		luaL_error(L, (std::string("C function error:::TestClass1::SetClass0Array:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass1::SetClass0Array");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4095)
/// <summary>
/// ::TestClass1::Create1()
/// </summary>
static int lm__TestClass1__Create1__0(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4127)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 0)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4437)
		// Call the c++ function.
		auto __lstickvar_ret = (::TestClass1*)::TestClass1::Create1();
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4631)
		Sticklib::push_lvalue<::TestClass1*>(L, __lstickvar_ret, true);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4713)
		luaL_error(L, (std::string("C function error:::TestClass1::Create1:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass1::Create1");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4095)
/// <summary>
/// ::TestClass1::TestClass1()
/// </summary>
static int lm__TestClass1__New__0(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4127)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 0)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4447)
		// Create the class object and give back it to lua.
		auto obj = new ::TestClass1();
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4477)
		Sticklib::push_lvalue<::TestClass1*>(L, obj, true);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4713)
		luaL_error(L, (std::string("C function error:::TestClass1::TestClass1:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass1::TestClass1");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4095)
/// <summary>
/// ::TestClass2::Get2(::TestClass1*& testClass1)
/// </summary>
static int lm__TestClass2__Get2__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4127)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4253)
		// Get the class object.
		::TestClass2 * __lstickobj;
		Sticklib::check_lvalue<::TestClass2*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4299)
		::TestClass1* testClass1;
		Sticklib::check_lvalue<::TestClass1*>(testClass1, L, 2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4410)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		auto __lstickvar_ret = (int)__lstickobj->Get2((::TestClass1*&)testClass1);
		__int64 _argout_0_1;
		Sticklib::T_to_U(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4631)
		Sticklib::push_lvalue<__int64>(L, _argout_0_1, false);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4631)
		Sticklib::push_lvalue<::TestClass1*>(L, testClass1, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4713)
		luaL_error(L, (std::string("C function error:::TestClass2::Get2:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass2::Get2");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4095)
/// <summary>
/// ::TestClass2::Create2(::TestClass2*& testClass2)
/// </summary>
static int lm__TestClass2__Create2__0(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4127)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 0)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4375)
		::TestClass2* testClass2;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4423)
		// Call the c++ function.
		::TestClass2::Create2((::TestClass2*&)testClass2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4631)
		Sticklib::push_lvalue<::TestClass2*>(L, testClass2, true);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4713)
		luaL_error(L, (std::string("C function error:::TestClass2::Create2:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass2::Create2");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4095)
/// <summary>
/// ::TestClass2::New(int a)
/// </summary>
static int lm__TestClass2__New__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4127)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4299)
		__int64 _argin_1_1;
		Sticklib::check_lvalue<__int64>(_argin_1_1, L, 1);
		int a;
		Sticklib::T_to_U(a, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4447)
		// Create the class object and give back it to lua.
		auto obj = new ::TestClass2((int)a);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4477)
		Sticklib::push_lvalue<::TestClass2*>(L, obj, true);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4713)
		luaL_error(L, (std::string("C function error:::TestClass2::New:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass2::New");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4095)
/// <summary>
/// ::CStickClassExampleApp::Output(wchar_t* message)
/// </summary>
static int lm__CStickClassExampleApp__Output__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4127)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4253)
		// Get the class object.
		::CStickClassExampleApp * __lstickobj;
		Sticklib::check_lvalue<::CStickClassExampleApp*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4299)
		std::string _argin_1_1;
		Sticklib::check_lvalue<std::string>(_argin_1_1, L, 2);
		std::wstring _argin_1_2;
		Sticklib::astring_to_wstring(_argin_1_2, _argin_1_1);
		wchar_t* message;
		Sticklib::wstring_to_wtext(message, _argin_1_2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4393)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		__lstickobj->Output((const wchar_t*)message);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4713)
		luaL_error(L, (std::string("C function error:::CStickClassExampleApp::Output:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::CStickClassExampleApp::Output");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8592)
/// <summary>
/// LuaStick initializing function.
/// luastick_init must be called to register the classes and its member functions.
/// </summary>
void luastick_init(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7483)
	// Register the global functions.
	Sticklib::push_table(L, "");
	{
		static struct luaL_Reg lm__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7502)
			{ "App", lm__App__0 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7513)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7483)
	// Register the static class '::TestSpace' and its static member functions.
	Sticklib::push_table(L, "TestSpace");
	{
		static struct luaL_Reg lm__TestSpace__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7502)
			{ "GetA", lm__TestSpace__GetA__0 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7513)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__TestSpace__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7796)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7483)
	// Register the static class '::TestClassA' and its static member functions.
	Sticklib::push_table(L, "TestClassA");
	{
		static struct luaL_Reg lm__TestClassA__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7502)
			{ "Get", lm__TestClassA__Get__0 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7513)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__TestClassA__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7796)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7483)
	// Register the static class '::TestClass0' and its static member functions.
	Sticklib::push_table(L, "TestClass0");
	{
		static struct luaL_Reg lm__TestClass0__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7502)
			{ "Create0", lm__TestClass0__Create0__0 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7502)
			{ "New", lm__TestClass0__New__0 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7513)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__TestClass0__Static);
	}

	// Register the enumeration in the static class '::TestClass0'
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7549)
	Sticklib::set_lvalue_to_table<__int64>(L, "J", (__int64)::TestClass0::J, false);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7549)
	Sticklib::set_lvalue_to_table<__int64>(L, "E", (__int64)::TestClass0::E, false);
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7549)
	Sticklib::set_lvalue_to_table<__int64>(L, "F", (__int64)::TestClass0::F, false);
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7549)
	Sticklib::set_lvalue_to_table<__int64>(L, "G", (__int64)::TestClass0::G, false);

	// Register the enumeration in the static class '::TestClass0'
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7541)
	Sticklib::push_table(L, "EnumA");
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7549)
	Sticklib::set_lvalue_to_table<__int64>(L, "AAA", (__int64)::TestClass0::EnumA::A, false);
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7549)
	Sticklib::set_lvalue_to_table<__int64>(L, "C", (__int64)::TestClass0::EnumA::C, false);
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7549)
	Sticklib::set_lvalue_to_table<__int64>(L, "B", (__int64)::TestClass0::EnumA::B, false);
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7558)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7727)
	// Register the regular class '::TestClass0' and its regular member functions.
	static struct luaL_Reg lm__TestClass0__Method[] =
	{
		{ "__gc", lm__TestClass0__Destructor },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7755)
		{ "Get", lm__TestClass0__Get__2 },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7755)
		{ "GetArray", lm__TestClass0__GetArray__2 },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7755)
		{ "GetEnumA", lm__TestClass0__GetEnumA__2 },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7755)
		{ "GetTitle", lm__TestClass0__GetTitle__1 },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7755)
		{ "GetX", lm__TestClass0__GetX__1 },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7755)
		{ "SetTitle", lm__TestClass0__SetTitle__2 },
		{ nullptr, nullptr },
	};
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7773)
	Sticklib::register_class(L, "lm__TestClass0__", lm__TestClass0__Method, nullptr);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7796)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7483)
	// Register the static class '::TestClass1' and its static member functions.
	Sticklib::push_table(L, "TestClass1");
	{
		static struct luaL_Reg lm__TestClass1__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7502)
			{ "Create1", lm__TestClass1__Create1__0 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7502)
			{ "New", lm__TestClass1__New__0 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7513)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__TestClass1__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7727)
	// Register the regular class '::TestClass1' and its regular member functions.
	static struct luaL_Reg lm__TestClass1__Method[] =
	{
		{ "__gc", lm__TestClass1__Destructor },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7755)
		{ "Get", lm__TestClass1__Get__1 },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7755)
		{ "GetClass0Array", lm__TestClass1__GetClass0Array__1 },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7755)
		{ "GetX", lm__TestClass1__GetX__1 },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7755)
		{ "SetClass0Array", lm__TestClass1__SetClass0Array__2 },
		{ nullptr, nullptr },
	};
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7782)
	Sticklib::register_class(L, "lm__TestClass1__", lm__TestClass1__Method, "lm__TestClass0__");

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7796)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7483)
	// Register the static class '::TestClass2' and its static member functions.
	Sticklib::push_table(L, "TestClass2");
	{
		static struct luaL_Reg lm__TestClass2__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7502)
			{ "Create2", lm__TestClass2__Create2__0 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7502)
			{ "New", lm__TestClass2__New__1 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7513)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__TestClass2__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7588)
	// Register the constants in the static class '::TestClass2'
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7612)
		::TestClass0& _var_1_1 = (::TestClass0&)::TestClass2::TESTCLASS0;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7626)
		::TestClass0* _var_1_2 = &_var_1_1;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7695)
		Sticklib::set_lvalue_to_table<::TestClass0*>(L, "TESTCLASS0", _var_1_2, false);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7727)
	// Register the regular class '::TestClass2' and its regular member functions.
	static struct luaL_Reg lm__TestClass2__Method[] =
	{
		{ "__gc", lm__TestClass2__Destructor },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7755)
		{ "Get2", lm__TestClass2__Get2__2 },
		{ nullptr, nullptr },
	};
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7773)
	Sticklib::register_class(L, "lm__TestClass2__", lm__TestClass2__Method, nullptr);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7796)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7483)
	// Register the static class '::CStickClassExampleApp' and its static member functions.
	Sticklib::push_table(L, "StickClassExampleApp");
	{
		static struct luaL_Reg lm__CStickClassExampleApp__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7513)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__CStickClassExampleApp__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7727)
	// Register the regular class '::CStickClassExampleApp' and its regular member functions.
	static struct luaL_Reg lm__CStickClassExampleApp__Method[] =
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7755)
		{ "Output", lm__CStickClassExampleApp__Output__2 },
		{ nullptr, nullptr },
	};
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7773)
	Sticklib::register_class(L, "lm__CStickClassExampleApp__", lm__CStickClassExampleApp__Method, nullptr);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7796)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7796)
	Sticklib::pop(L);

}

