// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8000)
// Generated by LuaStick, Jun  2 2020.

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8008)
#include "stdafx.h"
// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8008)
#include "..\..\LuaStick\files\Sticklib.h"
// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8008)
#include "StickTestDlg.h"
// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8016)
#include "Stick.h"

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5831)
/// <summary>
/// ::X::~X()
/// </summary>
static int lm__X__Destructor(lua_State* L)
{
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Get the class object.
		auto __wrapper = (StickInstanceWrapper*)Sticklib::check_classobject(L, 1, "lm__X__");
		if (__wrapper->own && __wrapper->ptr != nullptr)
		{
			delete (::X*)__wrapper->ptr;
			__wrapper->ptr = nullptr;
		}
	}
	catch (std::exception & e)
	{
		luaL_error(L, (std::string("C function error:::X::~X:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::~X");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5831)
/// <summary>
/// ::X::A::~A()
/// </summary>
static int lm__X__A__Destructor(lua_State* L)
{
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Get the class object.
		auto __wrapper = (StickInstanceWrapper*)Sticklib::check_classobject(L, 1, "lm__X__A__");
		if (__wrapper->own && __wrapper->ptr != nullptr)
		{
			delete (::X::A*)__wrapper->ptr;
			__wrapper->ptr = nullptr;
		}
	}
	catch (std::exception & e)
	{
		luaL_error(L, (std::string("C function error:::X::A::~A:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::A::~A");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5831)
/// <summary>
/// ::X::B::~B()
/// </summary>
static int lm__X__B__Destructor(lua_State* L)
{
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Get the class object.
		auto __wrapper = (StickInstanceWrapper*)Sticklib::check_classobject(L, 1, "lm__X__B__");
		if (__wrapper->own && __wrapper->ptr != nullptr)
		{
			delete (::X::B*)__wrapper->ptr;
			__wrapper->ptr = nullptr;
		}
	}
	catch (std::exception & e)
	{
		luaL_error(L, (std::string("C function error:::X::B::~B:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::B::~B");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5831)
/// <summary>
/// ::NM1::NM1_NM2::~NM1_NM2()
/// </summary>
static int lm__NM1__NM1_NM2__Destructor(lua_State* L)
{
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Get the class object.
		auto __wrapper = (StickInstanceWrapper*)Sticklib::check_classobject(L, 1, "lm__NM1__NM1_NM2__");
		if (__wrapper->own && __wrapper->ptr != nullptr)
		{
			delete (::NM1::NM1_NM2*)__wrapper->ptr;
			__wrapper->ptr = nullptr;
		}
	}
	catch (std::exception & e)
	{
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM2::~NM1_NM2:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM2::~NM1_NM2");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5831)
/// <summary>
/// ::NM1::NM1_NM3::~NM1_NM3()
/// </summary>
static int lm__NM1__NM1_NM3__Destructor(lua_State* L)
{
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Get the class object.
		auto __wrapper = (StickInstanceWrapper*)Sticklib::check_classobject(L, 1, "lm__NM1__NM1_NM3__");
		if (__wrapper->own && __wrapper->ptr != nullptr)
		{
			delete (::NM1::NM1_NM3*)__wrapper->ptr;
			__wrapper->ptr = nullptr;
		}
	}
	catch (std::exception & e)
	{
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM3::~NM1_NM3:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM3::~NM1_NM3");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5831)
/// <summary>
/// ::C::~C()
/// </summary>
static int lm__C__Destructor(lua_State* L)
{
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Get the class object.
		auto __wrapper = (StickInstanceWrapper*)Sticklib::check_classobject(L, 1, "lm__C__");
		if (__wrapper->own && __wrapper->ptr != nullptr)
		{
			delete (::C*)__wrapper->ptr;
			__wrapper->ptr = nullptr;
		}
	}
	catch (std::exception & e)
	{
		luaL_error(L, (std::string("C function error:::C::~C:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::C::~C");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5831)
/// <summary>
/// ::CStickTestDlg::~CStickTestDlg()
/// </summary>
static int lm__CStickTestDlg__Destructor(lua_State* L)
{
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Get the class object.
		auto __wrapper = (StickInstanceWrapper*)Sticklib::check_classobject(L, 1, "lm__CStickTestDlg__");
		if (__wrapper->own && __wrapper->ptr != nullptr)
		{
			delete (::CStickTestDlg*)__wrapper->ptr;
			__wrapper->ptr = nullptr;
		}
	}
	catch (std::exception & e)
	{
		luaL_error(L, (std::string("C function error:::CStickTestDlg::~CStickTestDlg:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::CStickTestDlg::~CStickTestDlg");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4069)
/// <summary>
/// ::MyArrayFunc0(std::vector<std::string>& v1)
/// </summary>
static int lm__MyArrayFunc0__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4101)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4261)
		std::vector<std::string> v1;
		Sticklib::check_array<std::string>(v1, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4381)
		// Call the c++ function.
		::MyArrayFunc0((std::vector<std::string>&)v1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4540)
		Sticklib::push_array<std::string>(L, v1);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4623)
		luaL_error(L, (std::string("C function error:::MyArrayFunc0:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::MyArrayFunc0");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4069)
/// <summary>
/// ::MyArrayFunc1(std::vector<int>& v1)
/// </summary>
static int lm__MyArrayFunc1__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4101)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4261)
		std::vector<__int64> _argin_1_1;
		Sticklib::check_array<__int64>(_argin_1_1, L, 1);
		std::vector<int> v1;
		Sticklib::vector_to_vector<int,__int64>(v1, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4381)
		// Call the c++ function.
		::MyArrayFunc1((std::vector<int>&)v1);
		std::vector<__int64> _argout_1_1;
		Sticklib::vector_to_vector<__int64,int>(_argout_1_1, v1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4540)
		Sticklib::push_array<__int64>(L, _argout_1_1);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4623)
		luaL_error(L, (std::string("C function error:::MyArrayFunc1:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::MyArrayFunc1");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4069)
/// <summary>
/// ::MyArrayFunc2(std::vector<std::wstring>& v1)
/// </summary>
static int lm__MyArrayFunc2__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4101)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4261)
		std::vector<std::string> _argin_1_1;
		Sticklib::check_array<std::string>(_argin_1_1, L, 1);
		std::vector<std::wstring> v1;
		Sticklib::vector_to_vector<std::wstring,std::string>(v1, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4381)
		// Call the c++ function.
		::MyArrayFunc2((std::vector<std::wstring>&)v1);
		std::vector<std::string> _argout_1_1;
		Sticklib::vector_to_vector<std::string,std::wstring>(_argout_1_1, v1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4540)
		Sticklib::push_array<std::string>(L, _argout_1_1);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4623)
		luaL_error(L, (std::string("C function error:::MyArrayFunc2:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::MyArrayFunc2");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4069)
/// <summary>
/// ::MyFunc1(std::wstring& wstr1, wchar_t* wcp2)
/// </summary>
static int lm__MyFunc1__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4101)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4261)
		std::string _argin_1_1;
		Sticklib::check_lvalue(_argin_1_1, L, 1);
		std::wstring wstr1;
		Sticklib::astring_to_wstring(wstr1, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4261)
		std::string _argin_2_1;
		Sticklib::check_lvalue(_argin_2_1, L, 2);
		std::wstring _argin_2_2;
		Sticklib::astring_to_wstring(_argin_2_2, _argin_2_1);
		wchar_t* wcp2;
		Sticklib::wstring_to_wtext(wcp2, _argin_2_2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4395)
		// Call the c++ function.
		auto __lstickvar_ret = (std::wstring)::MyFunc1((std::wstring&)wstr1, (const wchar_t*)wcp2);
		std::string _argout_0_1;
		Sticklib::wstring_to_astring(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4540)
		Sticklib::push_lvalue(L, _argout_0_1);
		std::string _argout_1_1;
		Sticklib::wstring_to_astring(_argout_1_1, wstr1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4540)
		Sticklib::push_lvalue(L, _argout_1_1);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4623)
		luaL_error(L, (std::string("C function error:::MyFunc1:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::MyFunc1");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4069)
/// <summary>
/// ::MyFunc2(double& v1, __int64 v2)
/// </summary>
static int lm__MyFunc2__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4101)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4261)
		double v1;
		Sticklib::check_lvalue(v1, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4261)
		__int64 v2;
		Sticklib::check_lvalue(v2, L, 2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4395)
		// Call the c++ function.
		auto __lstickvar_ret = (int)::MyFunc2((double&)v1, (__int64)v2);
		__int64 _argout_0_1;
		Sticklib::T_to_U(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4540)
		Sticklib::push_lvalue(L, _argout_0_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4540)
		Sticklib::push_lvalue(L, v1);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4623)
		luaL_error(L, (std::string("C function error:::MyFunc2:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::MyFunc2");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4069)
/// <summary>
/// ::ShowMessage(wchar_t* text)
/// </summary>
static int lm__ShowMessage__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4101)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4261)
		std::string _argin_1_1;
		Sticklib::check_lvalue(_argin_1_1, L, 1);
		std::wstring _argin_1_2;
		Sticklib::astring_to_wstring(_argin_1_2, _argin_1_1);
		wchar_t* text;
		Sticklib::wstring_to_wtext(text, _argin_1_2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4381)
		// Call the c++ function.
		::ShowMessage((const wchar_t*)text);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4623)
		luaL_error(L, (std::string("C function error:::ShowMessage:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::ShowMessage");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4069)
/// <summary>
/// ::ToStickTestDlg(void* data)
/// </summary>
static int lm__ToStickTestDlg__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4101)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4261)
		void* data;
		Sticklib::check_lvalue(data, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4395)
		// Call the c++ function.
		auto __lstickvar_ret = (::CStickTestDlg*)::ToStickTestDlg((void*)data);
		Sticklib::classobject _argout_0_1;
		Sticklib::typeptr_to_classobject<::CStickTestDlg>(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4530)
		Sticklib::push_classobject(L, false, _argout_0_1, "lm__CStickTestDlg__");
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4623)
		luaL_error(L, (std::string("C function error:::ToStickTestDlg:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::ToStickTestDlg");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4069)
/// <summary>
/// ::X::X()
/// </summary>
static int lm__X__New__0(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4101)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 0)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4405)
		// Create the class object and give back it to lua.
		auto obj = new ::X();
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4430)
		Sticklib::push_classobject(L, true, obj, "lm__X__");
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4623)
		luaL_error(L, (std::string("C function error:::X::X:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::X");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4069)
/// <summary>
/// ::X::A::FuncX(::X::Enum1& x)
/// </summary>
static int lm__X__A__FuncX__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4101)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4215)
		// Get the class object.
		::X::A * __lstickobj;
		Sticklib::check_classobject((Sticklib::classobject &)__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4261)
		__int64 _argin_1_1;
		Sticklib::check_lvalue(_argin_1_1, L, 2);
		::X::Enum1 x;
		Sticklib::int64_to_enumT<::X::Enum1>(x, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4353)
		// Call the c++ function.
		__lstickobj->FuncX((enum class ::X::Enum1&)x);
		__int64 _argout_1_1;
		Sticklib::enumT_to_int64<::X::Enum1>(_argout_1_1, x);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4540)
		Sticklib::push_lvalue(L, _argout_1_1);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4623)
		luaL_error(L, (std::string("C function error:::X::A::FuncX:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::A::FuncX");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4069)
/// <summary>
/// ::X::A::Get()
/// </summary>
static int lm__X__A__Get__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4101)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4215)
		// Get the class object.
		::X::A * __lstickobj;
		Sticklib::check_classobject((Sticklib::classobject &)__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4368)
		// Call the c++ function.
		auto __lstickvar_ret = (int)__lstickobj->Get();
		__int64 _argout_0_1;
		Sticklib::T_to_U(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4540)
		Sticklib::push_lvalue(L, _argout_0_1);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4623)
		luaL_error(L, (std::string("C function error:::X::A::Get:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::A::Get");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4069)
/// <summary>
/// ::X::A::GetSet(int* a)
/// </summary>
static int lm__X__A__GetSet__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4101)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4215)
		// Get the class object.
		::X::A * __lstickobj;
		Sticklib::check_classobject((Sticklib::classobject &)__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4326)
		int _argin_1_1;
		int* a = &_argin_1_1;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4353)
		// Call the c++ function.
		__lstickobj->GetSet((int*)a);
		int& _argout_1_1 = *a;
		__int64 _argout_1_2;
		Sticklib::T_to_U(_argout_1_2, _argout_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4540)
		Sticklib::push_lvalue(L, _argout_1_2);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4623)
		luaL_error(L, (std::string("C function error:::X::A::GetSet:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::A::GetSet");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4069)
/// <summary>
/// ::X::A::Set(int a)
/// </summary>
static int lm__X__A__Set__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4101)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4215)
		// Get the class object.
		::X::A * __lstickobj;
		Sticklib::check_classobject((Sticklib::classobject &)__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4261)
		__int64 _argin_1_1;
		Sticklib::check_lvalue(_argin_1_1, L, 2);
		int a;
		Sticklib::T_to_U(a, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4353)
		// Call the c++ function.
		__lstickobj->Set((int)a);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4623)
		luaL_error(L, (std::string("C function error:::X::A::Set:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::A::Set");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4069)
/// <summary>
/// ::X::A::Set(int a, int b)
/// </summary>
static int lm__X__A__Set__3(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4101)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 3)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4215)
		// Get the class object.
		::X::A * __lstickobj;
		Sticklib::check_classobject((Sticklib::classobject &)__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4261)
		__int64 _argin_1_1;
		Sticklib::check_lvalue(_argin_1_1, L, 2);
		int a;
		Sticklib::T_to_U(a, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4261)
		__int64 _argin_2_1;
		Sticklib::check_lvalue(_argin_2_1, L, 3);
		int b;
		Sticklib::T_to_U(b, _argin_2_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4353)
		// Call the c++ function.
		__lstickobj->Set((int)a, (int)b);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4623)
		luaL_error(L, (std::string("C function error:::X::A::Set:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::A::Set");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4069)
/// <summary>
/// ::X::A::New(int a)
/// </summary>
static int lm__X__A__New__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4101)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4261)
		__int64 _argin_1_1;
		Sticklib::check_lvalue(_argin_1_1, L, 1);
		int a;
		Sticklib::T_to_U(a, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4405)
		// Create the class object and give back it to lua.
		auto obj = new ::X::A((int)a);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4430)
		Sticklib::push_classobject(L, true, obj, "lm__X__A__");
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4623)
		luaL_error(L, (std::string("C function error:::X::A::New:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::A::New");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4069)
/// <summary>
/// ::X::B::Add1(::X::A*& a)
/// </summary>
static int lm__X__B__Add1__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4101)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4215)
		// Get the class object.
		::X::B * __lstickobj;
		Sticklib::check_classobject((Sticklib::classobject &)__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4337)
		::X::A* a;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4368)
		// Call the c++ function.
		auto __lstickvar_ret = (int)__lstickobj->Add1((::X::A*&)a);
		__int64 _argout_0_1;
		Sticklib::T_to_U(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4540)
		Sticklib::push_lvalue(L, _argout_0_1);
		Sticklib::classobject _argout_1_1;
		Sticklib::typeptr_to_classobject<::X::A>(_argout_1_1, a);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4530)
		Sticklib::push_classobject(L, false, _argout_1_1, "lm__X__A__");
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4623)
		luaL_error(L, (std::string("C function error:::X::B::Add1:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::B::Add1");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4069)
/// <summary>
/// ::X::B::Add2(::X::A* a)
/// </summary>
static int lm__X__B__Add2__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4101)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4215)
		// Get the class object.
		::X::B * __lstickobj;
		Sticklib::check_classobject((Sticklib::classobject &)__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4261)
		Sticklib::classobject _argin_1_1;
		Sticklib::check_classobject(_argin_1_1, L, 2);
		::X::A* a;
		Sticklib::classobject_to_typeptr<::X::A>(a, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4353)
		// Call the c++ function.
		__lstickobj->Add2((class ::X::A*)a);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4623)
		luaL_error(L, (std::string("C function error:::X::B::Add2:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::B::Add2");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4069)
/// <summary>
/// ::X::B::CreateA(int a)
/// </summary>
static int lm__X__B__CreateA__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4101)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4261)
		__int64 _argin_1_1;
		Sticklib::check_lvalue(_argin_1_1, L, 1);
		int a;
		Sticklib::T_to_U(a, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4395)
		// Call the c++ function.
		auto __lstickvar_ret = (::X::A*)::X::B::CreateA((int)a);
		Sticklib::classobject _argout_0_1;
		Sticklib::typeptr_to_classobject<::X::A>(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4530)
		Sticklib::push_classobject(L, false, _argout_0_1, "lm__X__A__");
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4623)
		luaL_error(L, (std::string("C function error:::X::B::CreateA:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::B::CreateA");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4069)
/// <summary>
/// ::X::B::DeleteA(::X::A* a)
/// </summary>
static int lm__X__B__DeleteA__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4101)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4261)
		Sticklib::classobject _argin_1_1;
		Sticklib::check_classobject(_argin_1_1, L, 1);
		::X::A* a;
		Sticklib::classobject_to_typeptr<::X::A>(a, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4381)
		// Call the c++ function.
		::X::B::DeleteA((::X::A*)a);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4623)
		luaL_error(L, (std::string("C function error:::X::B::DeleteA:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::B::DeleteA");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4069)
/// <summary>
/// ::X::B::B()
/// </summary>
static int lm__X__B__New__0(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4101)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 0)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4405)
		// Create the class object and give back it to lua.
		auto obj = new ::X::B();
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4430)
		Sticklib::push_classobject(L, true, obj, "lm__X__B__");
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4623)
		luaL_error(L, (std::string("C function error:::X::B::B:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::B::B");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4069)
/// <summary>
/// ::NM1::MyFunc2(double& v1, __int64 v2)
/// </summary>
static int lm__NM1__MyFunc2__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4101)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4261)
		double v1;
		Sticklib::check_lvalue(v1, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4261)
		__int64 v2;
		Sticklib::check_lvalue(v2, L, 2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4395)
		// Call the c++ function.
		auto __lstickvar_ret = (int)::NM1::MyFunc2((double&)v1, (__int64)v2);
		__int64 _argout_0_1;
		Sticklib::T_to_U(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4540)
		Sticklib::push_lvalue(L, _argout_0_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4540)
		Sticklib::push_lvalue(L, v1);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4623)
		luaL_error(L, (std::string("C function error:::NM1::MyFunc2:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::MyFunc2");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4069)
/// <summary>
/// ::NM1::NM1_NM1::MyFunc0(void* array)
/// </summary>
static int lm__NM1__NM1_NM1__MyFunc0__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4101)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4261)
		void* array;
		Sticklib::check_lvalue(array, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4381)
		// Call the c++ function.
		::NM1::NM1_NM1::MyFunc0((const int*)array);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4623)
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM1::MyFunc0:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM1::MyFunc0");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4069)
/// <summary>
/// ::NM1::NM1_NM1::MyFunc1(std::wstring& wstr1, wchar_t* wcp2)
/// </summary>
static int lm__NM1__NM1_NM1__MyFunc1__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4101)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4261)
		std::string _argin_1_1;
		Sticklib::check_lvalue(_argin_1_1, L, 1);
		std::wstring wstr1;
		Sticklib::astring_to_wstring(wstr1, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4261)
		std::string _argin_2_1;
		Sticklib::check_lvalue(_argin_2_1, L, 2);
		std::wstring _argin_2_2;
		Sticklib::astring_to_wstring(_argin_2_2, _argin_2_1);
		wchar_t* wcp2;
		Sticklib::wstring_to_wtext(wcp2, _argin_2_2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4395)
		// Call the c++ function.
		auto __lstickvar_ret = (std::wstring)::NM1::NM1_NM1::MyFunc1((std::wstring&)wstr1, (const wchar_t*)wcp2);
		std::string _argout_0_1;
		Sticklib::wstring_to_astring(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4540)
		Sticklib::push_lvalue(L, _argout_0_1);
		std::string _argout_1_1;
		Sticklib::wstring_to_astring(_argout_1_1, wstr1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4540)
		Sticklib::push_lvalue(L, _argout_1_1);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4623)
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM1::MyFunc1:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM1::MyFunc1");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4069)
/// <summary>
/// ::NM1::NM1_NM1::MyFunc2(std::string& v1)
/// </summary>
static int lm__NM1__NM1_NM1__MyFunc2x__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4101)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4261)
		std::string v1;
		Sticklib::check_lvalue(v1, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4395)
		// Call the c++ function.
		auto __lstickvar_ret = (int)::NM1::NM1_NM1::MyFunc2((std::string&)v1);
		__int64 _argout_0_1;
		Sticklib::T_to_U(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4540)
		Sticklib::push_lvalue(L, _argout_0_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4540)
		Sticklib::push_lvalue(L, v1);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4623)
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM1::MyFunc2:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM1::MyFunc2");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4069)
/// <summary>
/// ::NM1::NM1_NM1::MyFunc2(double& v1)
/// </summary>
static int lm__NM1__NM1_NM1__MyFunc2y__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4101)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4261)
		double v1;
		Sticklib::check_lvalue(v1, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4395)
		// Call the c++ function.
		auto __lstickvar_ret = (int)::NM1::NM1_NM1::MyFunc2((double&)v1);
		__int64 _argout_0_1;
		Sticklib::T_to_U(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4540)
		Sticklib::push_lvalue(L, _argout_0_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4540)
		Sticklib::push_lvalue(L, v1);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4623)
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM1::MyFunc2:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM1::MyFunc2");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4069)
/// <summary>
/// ::NM1::NM1_NM1::MyFunc2(double& v1, __int64 v2)
/// </summary>
static int lm__NM1__NM1_NM1__MyFunc2y__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4101)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4261)
		double v1;
		Sticklib::check_lvalue(v1, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4261)
		__int64 v2;
		Sticklib::check_lvalue(v2, L, 2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4395)
		// Call the c++ function.
		auto __lstickvar_ret = (int)::NM1::NM1_NM1::MyFunc2((double&)v1, (__int64)v2);
		__int64 _argout_0_1;
		Sticklib::T_to_U(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4540)
		Sticklib::push_lvalue(L, _argout_0_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4540)
		Sticklib::push_lvalue(L, v1);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4623)
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM1::MyFunc2:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM1::MyFunc2");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4069)
/// <summary>
/// ::NM1::NM1_NM2::MyFunc2(double& v1, __int64 v2)
/// </summary>
static int lm__NM1__NM1_NM2__MyFunc2__3(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4101)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 3)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4215)
		// Get the class object.
		::NM1::NM1_NM2 * __lstickobj;
		Sticklib::check_classobject((Sticklib::classobject &)__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4261)
		double v1;
		Sticklib::check_lvalue(v1, L, 2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4261)
		__int64 v2;
		Sticklib::check_lvalue(v2, L, 3);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4368)
		// Call the c++ function.
		auto __lstickvar_ret = (int)__lstickobj->MyFunc2((double&)v1, (__int64)v2);
		__int64 _argout_0_1;
		Sticklib::T_to_U(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4540)
		Sticklib::push_lvalue(L, _argout_0_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4540)
		Sticklib::push_lvalue(L, v1);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4623)
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM2::MyFunc2:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM2::MyFunc2");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4069)
/// <summary>
/// ::NM1::NM1_NM2::New()
/// </summary>
static int lm__NM1__NM1_NM2__New__0(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4101)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 0)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4405)
		// Create the class object and give back it to lua.
		auto obj = new ::NM1::NM1_NM2();
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4430)
		Sticklib::push_classobject(L, true, obj, "lm__NM1__NM1_NM2__");
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4623)
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM2::New:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM2::New");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4069)
/// <summary>
/// ::NM1::NM1_NM2::New(int& a)
/// </summary>
static int lm__NM1__NM1_NM2__New__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4101)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4261)
		__int64 _argin_1_1;
		Sticklib::check_lvalue(_argin_1_1, L, 1);
		int a;
		Sticklib::T_to_U(a, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4405)
		// Create the class object and give back it to lua.
		auto obj = new ::NM1::NM1_NM2((int&)a);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4430)
		Sticklib::push_classobject(L, true, obj, "lm__NM1__NM1_NM2__");
		__int64 _argout_1_1;
		Sticklib::T_to_U(_argout_1_1, a);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4540)
		Sticklib::push_lvalue(L, _argout_1_1);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4623)
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM2::New:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM2::New");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4069)
/// <summary>
/// ::NM1::NM1_NM3::MyFunc3(double& v1)
/// </summary>
static int lm__NM1__NM1_NM3__MyFunc3__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4101)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4215)
		// Get the class object.
		::NM1::NM1_NM3 * __lstickobj;
		Sticklib::check_classobject((Sticklib::classobject &)__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4261)
		double v1;
		Sticklib::check_lvalue(v1, L, 2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4368)
		// Call the c++ function.
		auto __lstickvar_ret = (int)__lstickobj->MyFunc3((double&)v1);
		__int64 _argout_0_1;
		Sticklib::T_to_U(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4540)
		Sticklib::push_lvalue(L, _argout_0_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4540)
		Sticklib::push_lvalue(L, v1);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4623)
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM3::MyFunc3:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM3::MyFunc3");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4069)
/// <summary>
/// ::NM1::NM1_NM3::MyFunc3(double& v1, __int64 v2)
/// </summary>
static int lm__NM1__NM1_NM3__MyFunc3__3(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4101)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 3)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4215)
		// Get the class object.
		::NM1::NM1_NM3 * __lstickobj;
		Sticklib::check_classobject((Sticklib::classobject &)__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4261)
		double v1;
		Sticklib::check_lvalue(v1, L, 2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4261)
		__int64 v2;
		Sticklib::check_lvalue(v2, L, 3);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4368)
		// Call the c++ function.
		auto __lstickvar_ret = (int)__lstickobj->MyFunc3((double&)v1, (__int64)v2);
		__int64 _argout_0_1;
		Sticklib::T_to_U(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4540)
		Sticklib::push_lvalue(L, _argout_0_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4540)
		Sticklib::push_lvalue(L, v1);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4623)
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM3::MyFunc3:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM3::MyFunc3");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4069)
/// <summary>
/// ::NM1::NM1_NM3::NM1_NM3()
/// </summary>
static int lm__NM1__NM1_NM3__New__0(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4101)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 0)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4405)
		// Create the class object and give back it to lua.
		auto obj = new ::NM1::NM1_NM3();
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4430)
		Sticklib::push_classobject(L, true, obj, "lm__NM1__NM1_NM3__");
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4623)
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM3::NM1_NM3:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM3::NM1_NM3");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4069)
/// <summary>
/// ::C::C()
/// </summary>
static int lm__C__New__0(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4101)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 0)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4405)
		// Create the class object and give back it to lua.
		auto obj = new ::C();
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4430)
		Sticklib::push_classobject(L, true, obj, "lm__C__");
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4623)
		luaL_error(L, (std::string("C function error:::C::C:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::C::C");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4069)
/// <summary>
/// ::NM2::MyFunc2(double& v1, __int64 v2)
/// </summary>
static int lm__NM2__MyFunc2__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4101)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4261)
		double v1;
		Sticklib::check_lvalue(v1, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4261)
		__int64 v2;
		Sticklib::check_lvalue(v2, L, 2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4395)
		// Call the c++ function.
		auto __lstickvar_ret = (int)::NM2::MyFunc2((double&)v1, (__int64)v2);
		__int64 _argout_0_1;
		Sticklib::T_to_U(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4540)
		Sticklib::push_lvalue(L, _argout_0_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4540)
		Sticklib::push_lvalue(L, v1);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4623)
		luaL_error(L, (std::string("C function error:::NM2::MyFunc2:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM2::MyFunc2");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4069)
/// <summary>
/// ::CStickTestDlg::DebugOutput(char* message)
/// </summary>
static int lm__CStickTestDlg__DebugOutput__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4101)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4215)
		// Get the class object.
		::CStickTestDlg * __lstickobj;
		Sticklib::check_classobject((Sticklib::classobject &)__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4261)
		std::string _argin_1_1;
		Sticklib::check_lvalue(_argin_1_1, L, 2);
		char* message;
		Sticklib::astring_to_atext(message, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4353)
		// Call the c++ function.
		__lstickobj->DebugOutput((const char*)message);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4623)
		luaL_error(L, (std::string("C function error:::CStickTestDlg::DebugOutput:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::CStickTestDlg::DebugOutput");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4069)
/// <summary>
/// ::CStickTestDlg::CStickTestDlg()
/// </summary>
static int lm__CStickTestDlg__New__0(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4101)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 0)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4405)
		// Create the class object and give back it to lua.
		auto obj = new ::CStickTestDlg();
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4430)
		Sticklib::push_classobject(L, true, obj, "lm__CStickTestDlg__");
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4623)
		luaL_error(L, (std::string("C function error:::CStickTestDlg::CStickTestDlg:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::CStickTestDlg::CStickTestDlg");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6886)
/// <summary>
/// X.A.Set(...)
/// Distribute the process to the polymorphic functions. X.A.Set(...)
/// </summary>
static int lm__X__A__Set(lua_State* L)
{
	switch (lua_gettop(L))
	{
	case 2:
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6897)
		return lm__X__A__Set__2(L);
	case 3:
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6897)
		return lm__X__A__Set__3(L);
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6907)
	default:
		luaL_error(L, "incorrect argument");
		return 0;
	}
}
// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6886)
/// <summary>
/// NM1.MMM1.MyFunc2y(...)
/// Distribute the process to the polymorphic functions. NM1.MMM1.MyFunc2y(...)
/// </summary>
static int lm__NM1__NM1_NM1__MyFunc2y(lua_State* L)
{
	switch (lua_gettop(L))
	{
	case 1:
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6897)
		return lm__NM1__NM1_NM1__MyFunc2y__1(L);
	case 2:
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6897)
		return lm__NM1__NM1_NM1__MyFunc2y__2(L);
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6907)
	default:
		luaL_error(L, "incorrect argument");
		return 0;
	}
}
// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6886)
/// <summary>
/// NM1.NM1_NM2.New(...)
/// Distribute the process to the polymorphic functions. NM1.NM1_NM2.New(...)
/// </summary>
static int lm__NM1__NM1_NM2__New(lua_State* L)
{
	switch (lua_gettop(L))
	{
	case 0:
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6897)
		return lm__NM1__NM1_NM2__New__0(L);
	case 1:
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6897)
		return lm__NM1__NM1_NM2__New__1(L);
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6907)
	default:
		luaL_error(L, "incorrect argument");
		return 0;
	}
}
// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6886)
/// <summary>
/// NM1.NM1_NM3.MyFunc3(...)
/// Distribute the process to the polymorphic functions. NM1.NM1_NM3.MyFunc3(...)
/// </summary>
static int lm__NM1__NM1_NM3__MyFunc3(lua_State* L)
{
	switch (lua_gettop(L))
	{
	case 2:
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6897)
		return lm__NM1__NM1_NM3__MyFunc3__2(L);
	case 3:
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6897)
		return lm__NM1__NM1_NM3__MyFunc3__3(L);
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6907)
	default:
		luaL_error(L, "incorrect argument");
		return 0;
	}
}
// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8136)
/// <summary>
/// LuaStick initializing function.
/// luastick_init must be called to register the classes and its member functions.
/// </summary>
void luastick_init(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7114)
	// Register the global functions.
	Sticklib::push_table(L, "");
	{
		static struct luaL_Reg lm__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7133)
			{ "MyArrayFunc0", lm__MyArrayFunc0__1 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7133)
			{ "MyArrayFunc1", lm__MyArrayFunc1__1 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7133)
			{ "MyArrayFunc2", lm__MyArrayFunc2__1 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7133)
			{ "MyFunc1", lm__MyFunc1__2 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7133)
			{ "MyFunc2", lm__MyFunc2__2 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7133)
			{ "ShowMessage", lm__ShowMessage__1 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7133)
			{ "ToStickTestDlg", lm__ToStickTestDlg__1 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7144)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7219)
	// Register the constants in the static class ''
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7243)
		int& _var_1_1 = (int&)::HIJ;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7266)
		__int64 _var_1_2;
		Sticklib::T_to_U(_var_1_2, _var_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7293)
		Sticklib::set_lvalue_to_table(L, "HIJ", _var_1_2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7243)
		::X::B*& _var_2_1 = (::X::B*&)::XXBB;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7266)
		Sticklib::classobject _var_2_2;
		Sticklib::typeptr_to_classobject<::X::B>(_var_2_2, _var_2_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7285)
		Sticklib::set_classobject_to_table(L, "XXBB", false, _var_2_2, "lm__X__B__");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7243)
		char* _var_3_1 = (char*)XXX;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7266)
		std::string _var_3_2;
		Sticklib::atext_to_astring(_var_3_2, _var_3_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7293)
		Sticklib::set_lvalue_to_table(L, "XXX", _var_3_2);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7114)
	// Register the static class '::X' and its static member functions.
	Sticklib::push_table(L, "X");
	{
		static struct luaL_Reg lm__X__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7133)
			{ "New", lm__X__New__0 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7144)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__X__Static);
	}

	// Register the enumeration in the static class '::X'

	// Register the enumeration in the static class '::X'
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7172)
	Sticklib::push_table(L, "Enum1");
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7189)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7219)
	// Register the constants in the static class '::X'
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7243)
		int& _var_1_1 = (int&)::X::EFG;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7266)
		__int64 _var_1_2;
		Sticklib::T_to_U(_var_1_2, _var_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7293)
		Sticklib::set_lvalue_to_table(L, "EFG", _var_1_2);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7323)
	// Register the regular class '::X' and its regular member functions.
	static struct luaL_Reg lm__X__Method[] =
	{
		{ "__gc", lm__X__Destructor },
		{ nullptr, nullptr },
	};
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7369)
	Sticklib::register_class(L, "lm__X__", lm__X__Method, nullptr);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7114)
	// Register the static class '::X::A' and its static member functions.
	Sticklib::push_table(L, "A");
	{
		static struct luaL_Reg lm__X__A__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7133)
			{ "New", lm__X__A__New__1 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7144)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__X__A__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7219)
	// Register the constants in the static class '::X::A'
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7243)
		char*& _var_1_1 = (char*&)::X::A::ABC;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7266)
		std::string _var_1_2;
		Sticklib::atext_to_astring(_var_1_2, _var_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7293)
		Sticklib::set_lvalue_to_table(L, "ABC", _var_1_2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7243)
		int& _var_2_1 = (int&)::X::A::EFG;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7266)
		__int64 _var_2_2;
		Sticklib::T_to_U(_var_2_2, _var_2_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7293)
		Sticklib::set_lvalue_to_table(L, "EFG", _var_2_2);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7323)
	// Register the regular class '::X::A' and its regular member functions.
	static struct luaL_Reg lm__X__A__Method[] =
	{
		{ "__gc", lm__X__A__Destructor },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7351)
		{ "FuncX", lm__X__A__FuncX__2 },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7351)
		{ "Get", lm__X__A__Get__1 },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7351)
		{ "GetSet", lm__X__A__GetSet__1 },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7351)
		{ "Set", lm__X__A__Set },
		{ nullptr, nullptr },
	};
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7369)
	Sticklib::register_class(L, "lm__X__A__", lm__X__A__Method, nullptr);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7392)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7114)
	// Register the static class '::X::B' and its static member functions.
	Sticklib::push_table(L, "B");
	{
		static struct luaL_Reg lm__X__B__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7133)
			{ "CreateA", lm__X__B__CreateA__1 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7133)
			{ "DeleteA", lm__X__B__DeleteA__1 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7133)
			{ "New", lm__X__B__New__0 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7144)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__X__B__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7323)
	// Register the regular class '::X::B' and its regular member functions.
	static struct luaL_Reg lm__X__B__Method[] =
	{
		{ "__gc", lm__X__B__Destructor },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7351)
		{ "Add1", lm__X__B__Add1__1 },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7351)
		{ "Add2", lm__X__B__Add2__2 },
		{ nullptr, nullptr },
	};
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7369)
	Sticklib::register_class(L, "lm__X__B__", lm__X__B__Method, nullptr);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7392)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7392)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7114)
	// Register the static class '::NM1' and its static member functions.
	Sticklib::push_table(L, "NM1");
	{
		static struct luaL_Reg lm__NM1__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7133)
			{ "MyFunc2", lm__NM1__MyFunc2__2 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7144)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__NM1__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7114)
	// Register the static class '::NM1::NM1_NM1' and its static member functions.
	Sticklib::push_table(L, "MMM1");
	{
		static struct luaL_Reg lm__NM1__NM1_NM1__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7133)
			{ "MyFunc0", lm__NM1__NM1_NM1__MyFunc0__1 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7133)
			{ "MyFunc1", lm__NM1__NM1_NM1__MyFunc1__2 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7133)
			{ "MyFunc2x", lm__NM1__NM1_NM1__MyFunc2x__1 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7133)
			{ "MyFunc2y", lm__NM1__NM1_NM1__MyFunc2y },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7144)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__NM1__NM1_NM1__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7219)
	// Register the constants in the static class '::NM1::NM1_NM1'
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7243)
		void*& _var_1_1 = (void*&)::NM1::NM1_NM1::ARRAY;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7293)
		Sticklib::set_lvalue_to_table(L, "ARRAY", _var_1_1);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7392)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7114)
	// Register the static class '::NM1::NM1_NM2' and its static member functions.
	Sticklib::push_table(L, "NM1_NM2");
	{
		static struct luaL_Reg lm__NM1__NM1_NM2__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7133)
			{ "New", lm__NM1__NM1_NM2__New },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7144)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__NM1__NM1_NM2__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7323)
	// Register the regular class '::NM1::NM1_NM2' and its regular member functions.
	static struct luaL_Reg lm__NM1__NM1_NM2__Method[] =
	{
		{ "__gc", lm__NM1__NM1_NM2__Destructor },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7351)
		{ "MyFunc2", lm__NM1__NM1_NM2__MyFunc2__3 },
		{ nullptr, nullptr },
	};
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7369)
	Sticklib::register_class(L, "lm__NM1__NM1_NM2__", lm__NM1__NM1_NM2__Method, nullptr);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7392)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7114)
	// Register the static class '::NM1::NM1_NM3' and its static member functions.
	Sticklib::push_table(L, "NM1_NM3");
	{
		static struct luaL_Reg lm__NM1__NM1_NM3__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7133)
			{ "New", lm__NM1__NM1_NM3__New__0 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7144)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__NM1__NM1_NM3__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7323)
	// Register the regular class '::NM1::NM1_NM3' and its regular member functions.
	static struct luaL_Reg lm__NM1__NM1_NM3__Method[] =
	{
		{ "__gc", lm__NM1__NM1_NM3__Destructor },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7351)
		{ "MyFunc3", lm__NM1__NM1_NM3__MyFunc3 },
		{ nullptr, nullptr },
	};
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7378)
	Sticklib::register_class(L, "lm__NM1__NM1_NM3__", lm__NM1__NM1_NM3__Method, "lm__NM1__NM1_NM2__");

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7392)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7392)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7114)
	// Register the static class '::C' and its static member functions.
	Sticklib::push_table(L, "C");
	{
		static struct luaL_Reg lm__C__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7133)
			{ "New", lm__C__New__0 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7144)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__C__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7323)
	// Register the regular class '::C' and its regular member functions.
	static struct luaL_Reg lm__C__Method[] =
	{
		{ "__gc", lm__C__Destructor },
		{ nullptr, nullptr },
	};
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7378)
	Sticklib::register_class(L, "lm__C__", lm__C__Method, "lm__NM1__NM1_NM3__");

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7392)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7114)
	// Register the static class '::NM2' and its static member functions.
	Sticklib::push_table(L, "NM2");
	{
		static struct luaL_Reg lm__NM2__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7133)
			{ "MyFunc2", lm__NM2__MyFunc2__2 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7144)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__NM2__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7392)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7114)
	// Register the static class '::CStickTestDlg' and its static member functions.
	Sticklib::push_table(L, "CStickTestDlg");
	{
		static struct luaL_Reg lm__CStickTestDlg__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7133)
			{ "New", lm__CStickTestDlg__New__0 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7144)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__CStickTestDlg__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7323)
	// Register the regular class '::CStickTestDlg' and its regular member functions.
	static struct luaL_Reg lm__CStickTestDlg__Method[] =
	{
		{ "__gc", lm__CStickTestDlg__Destructor },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7351)
		{ "DebugOutput", lm__CStickTestDlg__DebugOutput__2 },
		{ nullptr, nullptr },
	};
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7369)
	Sticklib::register_class(L, "lm__CStickTestDlg__", lm__CStickTestDlg__Method, nullptr);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7392)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7392)
	Sticklib::pop(L);

}

