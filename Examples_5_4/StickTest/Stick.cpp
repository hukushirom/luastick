// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8593)
// Generated by LuaStick, May 27 2021.

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8601)
#include "stdafx.h"
// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8601)
#include "..\..\LuaStick\files\Sticklib.h"
// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8601)
#include "StickTestDlg.h"
// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8609)
#include "Stick.h"

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5752)
/// <summary>
/// Gets ::X value from Lua stack.
/// </summary>
template<>
void Sticklib::check_lvalue<::X*>(::X * & value, lua_State * L, int arg)
{
	//        stack
	//     :          :
	//     |----------|            +------------------+
	//  arg| userdata |----------->| allocated memory |
	//     |----------|            +------------------+
	//     :          :
	//                             |------------------|
	//                           sizeof(StickInstanceWrapper)
	//
	// Premise for following.
	//

	// lua_touserdata is valid for userdata and lightuserdata both.
	auto wrapper = (StickInstanceWrapper *)lua_touserdata(L, arg);
	if (!wrapper)
		throw std::invalid_argument("The argument is not userdata nor lightuserdata");
	value = (::X *)wrapper->ptr;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5752)
/// <summary>
/// Gets ::X::A value from Lua stack.
/// </summary>
template<>
void Sticklib::check_lvalue<::X::A*>(::X::A * & value, lua_State * L, int arg)
{
	//        stack
	//     :          :
	//     |----------|            +------------------+
	//  arg| userdata |----------->| allocated memory |
	//     |----------|            +------------------+
	//     :          :
	//                             |------------------|
	//                           sizeof(StickInstanceWrapper)
	//
	// Premise for following.
	//

	// lua_touserdata is valid for userdata and lightuserdata both.
	auto wrapper = (StickInstanceWrapper *)lua_touserdata(L, arg);
	if (!wrapper)
		throw std::invalid_argument("The argument is not userdata nor lightuserdata");
	value = (::X::A *)wrapper->ptr;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5752)
/// <summary>
/// Gets ::X::B value from Lua stack.
/// </summary>
template<>
void Sticklib::check_lvalue<::X::B*>(::X::B * & value, lua_State * L, int arg)
{
	//        stack
	//     :          :
	//     |----------|            +------------------+
	//  arg| userdata |----------->| allocated memory |
	//     |----------|            +------------------+
	//     :          :
	//                             |------------------|
	//                           sizeof(StickInstanceWrapper)
	//
	// Premise for following.
	//

	// lua_touserdata is valid for userdata and lightuserdata both.
	auto wrapper = (StickInstanceWrapper *)lua_touserdata(L, arg);
	if (!wrapper)
		throw std::invalid_argument("The argument is not userdata nor lightuserdata");
	value = (::X::B *)wrapper->ptr;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5752)
/// <summary>
/// Gets ::NM1::NM1_NM2 value from Lua stack.
/// </summary>
template<>
void Sticklib::check_lvalue<::NM1::NM1_NM2*>(::NM1::NM1_NM2 * & value, lua_State * L, int arg)
{
	//        stack
	//     :          :
	//     |----------|            +------------------+
	//  arg| userdata |----------->| allocated memory |
	//     |----------|            +------------------+
	//     :          :
	//                             |------------------|
	//                           sizeof(StickInstanceWrapper)
	//
	// Premise for following.
	//

	// lua_touserdata is valid for userdata and lightuserdata both.
	auto wrapper = (StickInstanceWrapper *)lua_touserdata(L, arg);
	if (!wrapper)
		throw std::invalid_argument("The argument is not userdata nor lightuserdata");
	value = (::NM1::NM1_NM2 *)wrapper->ptr;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5752)
/// <summary>
/// Gets ::NM1::NM1_NM3 value from Lua stack.
/// </summary>
template<>
void Sticklib::check_lvalue<::NM1::NM1_NM3*>(::NM1::NM1_NM3 * & value, lua_State * L, int arg)
{
	//        stack
	//     :          :
	//     |----------|            +------------------+
	//  arg| userdata |----------->| allocated memory |
	//     |----------|            +------------------+
	//     :          :
	//                             |------------------|
	//                           sizeof(StickInstanceWrapper)
	//
	// Premise for following.
	//

	// lua_touserdata is valid for userdata and lightuserdata both.
	auto wrapper = (StickInstanceWrapper *)lua_touserdata(L, arg);
	if (!wrapper)
		throw std::invalid_argument("The argument is not userdata nor lightuserdata");
	value = (::NM1::NM1_NM3 *)wrapper->ptr;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5752)
/// <summary>
/// Gets ::C value from Lua stack.
/// </summary>
template<>
void Sticklib::check_lvalue<::C*>(::C * & value, lua_State * L, int arg)
{
	//        stack
	//     :          :
	//     |----------|            +------------------+
	//  arg| userdata |----------->| allocated memory |
	//     |----------|            +------------------+
	//     :          :
	//                             |------------------|
	//                           sizeof(StickInstanceWrapper)
	//
	// Premise for following.
	//

	// lua_touserdata is valid for userdata and lightuserdata both.
	auto wrapper = (StickInstanceWrapper *)lua_touserdata(L, arg);
	if (!wrapper)
		throw std::invalid_argument("The argument is not userdata nor lightuserdata");
	value = (::C *)wrapper->ptr;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5752)
/// <summary>
/// Gets ::CStickTestDlg value from Lua stack.
/// </summary>
template<>
void Sticklib::check_lvalue<::CStickTestDlg*>(::CStickTestDlg * & value, lua_State * L, int arg)
{
	//        stack
	//     :          :
	//     |----------|            +------------------+
	//  arg| userdata |----------->| allocated memory |
	//     |----------|            +------------------+
	//     :          :
	//                             |------------------|
	//                           sizeof(StickInstanceWrapper)
	//
	// Premise for following.
	//

	// lua_touserdata is valid for userdata and lightuserdata both.
	auto wrapper = (StickInstanceWrapper *)lua_touserdata(L, arg);
	if (!wrapper)
		throw std::invalid_argument("The argument is not userdata nor lightuserdata");
	value = (::CStickTestDlg *)wrapper->ptr;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6054)
/// <summary>
/// Pushes ::X value on Lua stack.
/// </summary>
template<>
void Sticklib::push_lvalue<::X*>(lua_State * L, ::X * const & value, bool own)
{
	//                   Premise.
	//       stack
	//    +---------+
	//  -1|   v1    |
	//    |---------|
	//    :         :
	//

	//       stack
	//    |---------|            +------------------+
	//  -1|userdata |----------->| allocated memory |
	//    |---------|            +------------------+
	//  -2|   v1    |
	//    |---------|            |------------------|
	//    :         :          sizeof(StickInstanceWrapper)
	//
	auto ptr = (StickInstanceWrapper *)lua_newuserdata(L, sizeof(StickInstanceWrapper));
	ptr->own = own;
	ptr->ptr = value;

	//       stack
	//    |---------|
	//  -1|metatable|--------------------------+   +----------------------------------------+
	//    |---------|                          |   |                       registry         |
	//  -2|userdata |---+                      V   V                    +-------+-------+   |
	//    |---------|   |              +----------+--------+            | Key   | Value |   |
	//    |   v1    |   |              |   Key    | Value  |            |-------|-------|   |
	//    |---------|   |              |----------|--------|            |regName| table |---+
	//    :         :   |              |  "__gc"  |c++func1<---+        +---A---+-------+
	//                  |              +----------|--------+   |        :   |   :       :
	//                  |              | "xxxxx"  |c++func2|   |            |
	//                  |              +----------|--------+   |       metatable_name
	//                  |              :          :        :   |
	//                  |                                      |
	//                  |    +------------------+              |
	//                  +--->| allocated memory |        c++ Destructor
	//                       +------------------+
	//
	luaL_getmetatable(L, "lm__X__");

	//                             metatable
	//       stack              +--------------+   +----------------------------------------+
	//    |---------|           |              |   |                       registry         |
	//  -1|userdata |---+       |              V   V                    +-------+-------+   |
	//    |---------|   |       |      +----------+--------+            | Key   | Value |   |
	//    |   v1    |   |       |      |   Key    | Value  |            |-------|-------|   |
	//    |---------|   |       |      |----------|--------|            |regName| table |---+
	//    :         :   |       |      |  "__gc"  |c++func1<---+        +---A---+-------+
	//                  |       |      +----------|--------+   |        :   |   :       :
	//                  |       |      | "xxxxx"  |c++func2|   |            |
	//                  |       |      +----------|--------+   |       metatable_name
	//                  |       |      :          :        :   |
	//                  |       |                              |
	//                  |    +------------------+              |
	//                  +--->| allocated memory |        c++ Destructor
	//                       +------------------+
	//
	::lua_setmetatable(L, -2);
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6054)
/// <summary>
/// Pushes ::X::A value on Lua stack.
/// </summary>
template<>
void Sticklib::push_lvalue<::X::A*>(lua_State * L, ::X::A * const & value, bool own)
{
	//                   Premise.
	//       stack
	//    +---------+
	//  -1|   v1    |
	//    |---------|
	//    :         :
	//

	//       stack
	//    |---------|            +------------------+
	//  -1|userdata |----------->| allocated memory |
	//    |---------|            +------------------+
	//  -2|   v1    |
	//    |---------|            |------------------|
	//    :         :          sizeof(StickInstanceWrapper)
	//
	auto ptr = (StickInstanceWrapper *)lua_newuserdata(L, sizeof(StickInstanceWrapper));
	ptr->own = own;
	ptr->ptr = value;

	//       stack
	//    |---------|
	//  -1|metatable|--------------------------+   +----------------------------------------+
	//    |---------|                          |   |                       registry         |
	//  -2|userdata |---+                      V   V                    +-------+-------+   |
	//    |---------|   |              +----------+--------+            | Key   | Value |   |
	//    |   v1    |   |              |   Key    | Value  |            |-------|-------|   |
	//    |---------|   |              |----------|--------|            |regName| table |---+
	//    :         :   |              |  "__gc"  |c++func1<---+        +---A---+-------+
	//                  |              +----------|--------+   |        :   |   :       :
	//                  |              | "xxxxx"  |c++func2|   |            |
	//                  |              +----------|--------+   |       metatable_name
	//                  |              :          :        :   |
	//                  |                                      |
	//                  |    +------------------+              |
	//                  +--->| allocated memory |        c++ Destructor
	//                       +------------------+
	//
	luaL_getmetatable(L, "lm__X__A__");

	//                             metatable
	//       stack              +--------------+   +----------------------------------------+
	//    |---------|           |              |   |                       registry         |
	//  -1|userdata |---+       |              V   V                    +-------+-------+   |
	//    |---------|   |       |      +----------+--------+            | Key   | Value |   |
	//    |   v1    |   |       |      |   Key    | Value  |            |-------|-------|   |
	//    |---------|   |       |      |----------|--------|            |regName| table |---+
	//    :         :   |       |      |  "__gc"  |c++func1<---+        +---A---+-------+
	//                  |       |      +----------|--------+   |        :   |   :       :
	//                  |       |      | "xxxxx"  |c++func2|   |            |
	//                  |       |      +----------|--------+   |       metatable_name
	//                  |       |      :          :        :   |
	//                  |       |                              |
	//                  |    +------------------+              |
	//                  +--->| allocated memory |        c++ Destructor
	//                       +------------------+
	//
	::lua_setmetatable(L, -2);
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6054)
/// <summary>
/// Pushes ::X::B value on Lua stack.
/// </summary>
template<>
void Sticklib::push_lvalue<::X::B*>(lua_State * L, ::X::B * const & value, bool own)
{
	//                   Premise.
	//       stack
	//    +---------+
	//  -1|   v1    |
	//    |---------|
	//    :         :
	//

	//       stack
	//    |---------|            +------------------+
	//  -1|userdata |----------->| allocated memory |
	//    |---------|            +------------------+
	//  -2|   v1    |
	//    |---------|            |------------------|
	//    :         :          sizeof(StickInstanceWrapper)
	//
	auto ptr = (StickInstanceWrapper *)lua_newuserdata(L, sizeof(StickInstanceWrapper));
	ptr->own = own;
	ptr->ptr = value;

	//       stack
	//    |---------|
	//  -1|metatable|--------------------------+   +----------------------------------------+
	//    |---------|                          |   |                       registry         |
	//  -2|userdata |---+                      V   V                    +-------+-------+   |
	//    |---------|   |              +----------+--------+            | Key   | Value |   |
	//    |   v1    |   |              |   Key    | Value  |            |-------|-------|   |
	//    |---------|   |              |----------|--------|            |regName| table |---+
	//    :         :   |              |  "__gc"  |c++func1<---+        +---A---+-------+
	//                  |              +----------|--------+   |        :   |   :       :
	//                  |              | "xxxxx"  |c++func2|   |            |
	//                  |              +----------|--------+   |       metatable_name
	//                  |              :          :        :   |
	//                  |                                      |
	//                  |    +------------------+              |
	//                  +--->| allocated memory |        c++ Destructor
	//                       +------------------+
	//
	luaL_getmetatable(L, "lm__X__B__");

	//                             metatable
	//       stack              +--------------+   +----------------------------------------+
	//    |---------|           |              |   |                       registry         |
	//  -1|userdata |---+       |              V   V                    +-------+-------+   |
	//    |---------|   |       |      +----------+--------+            | Key   | Value |   |
	//    |   v1    |   |       |      |   Key    | Value  |            |-------|-------|   |
	//    |---------|   |       |      |----------|--------|            |regName| table |---+
	//    :         :   |       |      |  "__gc"  |c++func1<---+        +---A---+-------+
	//                  |       |      +----------|--------+   |        :   |   :       :
	//                  |       |      | "xxxxx"  |c++func2|   |            |
	//                  |       |      +----------|--------+   |       metatable_name
	//                  |       |      :          :        :   |
	//                  |       |                              |
	//                  |    +------------------+              |
	//                  +--->| allocated memory |        c++ Destructor
	//                       +------------------+
	//
	::lua_setmetatable(L, -2);
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6054)
/// <summary>
/// Pushes ::NM1::NM1_NM2 value on Lua stack.
/// </summary>
template<>
void Sticklib::push_lvalue<::NM1::NM1_NM2*>(lua_State * L, ::NM1::NM1_NM2 * const & value, bool own)
{
	//                   Premise.
	//       stack
	//    +---------+
	//  -1|   v1    |
	//    |---------|
	//    :         :
	//

	//       stack
	//    |---------|            +------------------+
	//  -1|userdata |----------->| allocated memory |
	//    |---------|            +------------------+
	//  -2|   v1    |
	//    |---------|            |------------------|
	//    :         :          sizeof(StickInstanceWrapper)
	//
	auto ptr = (StickInstanceWrapper *)lua_newuserdata(L, sizeof(StickInstanceWrapper));
	ptr->own = own;
	ptr->ptr = value;

	//       stack
	//    |---------|
	//  -1|metatable|--------------------------+   +----------------------------------------+
	//    |---------|                          |   |                       registry         |
	//  -2|userdata |---+                      V   V                    +-------+-------+   |
	//    |---------|   |              +----------+--------+            | Key   | Value |   |
	//    |   v1    |   |              |   Key    | Value  |            |-------|-------|   |
	//    |---------|   |              |----------|--------|            |regName| table |---+
	//    :         :   |              |  "__gc"  |c++func1<---+        +---A---+-------+
	//                  |              +----------|--------+   |        :   |   :       :
	//                  |              | "xxxxx"  |c++func2|   |            |
	//                  |              +----------|--------+   |       metatable_name
	//                  |              :          :        :   |
	//                  |                                      |
	//                  |    +------------------+              |
	//                  +--->| allocated memory |        c++ Destructor
	//                       +------------------+
	//
	luaL_getmetatable(L, "lm__NM1__NM1_NM2__");

	//                             metatable
	//       stack              +--------------+   +----------------------------------------+
	//    |---------|           |              |   |                       registry         |
	//  -1|userdata |---+       |              V   V                    +-------+-------+   |
	//    |---------|   |       |      +----------+--------+            | Key   | Value |   |
	//    |   v1    |   |       |      |   Key    | Value  |            |-------|-------|   |
	//    |---------|   |       |      |----------|--------|            |regName| table |---+
	//    :         :   |       |      |  "__gc"  |c++func1<---+        +---A---+-------+
	//                  |       |      +----------|--------+   |        :   |   :       :
	//                  |       |      | "xxxxx"  |c++func2|   |            |
	//                  |       |      +----------|--------+   |       metatable_name
	//                  |       |      :          :        :   |
	//                  |       |                              |
	//                  |    +------------------+              |
	//                  +--->| allocated memory |        c++ Destructor
	//                       +------------------+
	//
	::lua_setmetatable(L, -2);
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6054)
/// <summary>
/// Pushes ::NM1::NM1_NM3 value on Lua stack.
/// </summary>
template<>
void Sticklib::push_lvalue<::NM1::NM1_NM3*>(lua_State * L, ::NM1::NM1_NM3 * const & value, bool own)
{
	//                   Premise.
	//       stack
	//    +---------+
	//  -1|   v1    |
	//    |---------|
	//    :         :
	//

	//       stack
	//    |---------|            +------------------+
	//  -1|userdata |----------->| allocated memory |
	//    |---------|            +------------------+
	//  -2|   v1    |
	//    |---------|            |------------------|
	//    :         :          sizeof(StickInstanceWrapper)
	//
	auto ptr = (StickInstanceWrapper *)lua_newuserdata(L, sizeof(StickInstanceWrapper));
	ptr->own = own;
	ptr->ptr = value;

	//       stack
	//    |---------|
	//  -1|metatable|--------------------------+   +----------------------------------------+
	//    |---------|                          |   |                       registry         |
	//  -2|userdata |---+                      V   V                    +-------+-------+   |
	//    |---------|   |              +----------+--------+            | Key   | Value |   |
	//    |   v1    |   |              |   Key    | Value  |            |-------|-------|   |
	//    |---------|   |              |----------|--------|            |regName| table |---+
	//    :         :   |              |  "__gc"  |c++func1<---+        +---A---+-------+
	//                  |              +----------|--------+   |        :   |   :       :
	//                  |              | "xxxxx"  |c++func2|   |            |
	//                  |              +----------|--------+   |       metatable_name
	//                  |              :          :        :   |
	//                  |                                      |
	//                  |    +------------------+              |
	//                  +--->| allocated memory |        c++ Destructor
	//                       +------------------+
	//
	luaL_getmetatable(L, "lm__NM1__NM1_NM3__");

	//                             metatable
	//       stack              +--------------+   +----------------------------------------+
	//    |---------|           |              |   |                       registry         |
	//  -1|userdata |---+       |              V   V                    +-------+-------+   |
	//    |---------|   |       |      +----------+--------+            | Key   | Value |   |
	//    |   v1    |   |       |      |   Key    | Value  |            |-------|-------|   |
	//    |---------|   |       |      |----------|--------|            |regName| table |---+
	//    :         :   |       |      |  "__gc"  |c++func1<---+        +---A---+-------+
	//                  |       |      +----------|--------+   |        :   |   :       :
	//                  |       |      | "xxxxx"  |c++func2|   |            |
	//                  |       |      +----------|--------+   |       metatable_name
	//                  |       |      :          :        :   |
	//                  |       |                              |
	//                  |    +------------------+              |
	//                  +--->| allocated memory |        c++ Destructor
	//                       +------------------+
	//
	::lua_setmetatable(L, -2);
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6054)
/// <summary>
/// Pushes ::C value on Lua stack.
/// </summary>
template<>
void Sticklib::push_lvalue<::C*>(lua_State * L, ::C * const & value, bool own)
{
	//                   Premise.
	//       stack
	//    +---------+
	//  -1|   v1    |
	//    |---------|
	//    :         :
	//

	//       stack
	//    |---------|            +------------------+
	//  -1|userdata |----------->| allocated memory |
	//    |---------|            +------------------+
	//  -2|   v1    |
	//    |---------|            |------------------|
	//    :         :          sizeof(StickInstanceWrapper)
	//
	auto ptr = (StickInstanceWrapper *)lua_newuserdata(L, sizeof(StickInstanceWrapper));
	ptr->own = own;
	ptr->ptr = value;

	//       stack
	//    |---------|
	//  -1|metatable|--------------------------+   +----------------------------------------+
	//    |---------|                          |   |                       registry         |
	//  -2|userdata |---+                      V   V                    +-------+-------+   |
	//    |---------|   |              +----------+--------+            | Key   | Value |   |
	//    |   v1    |   |              |   Key    | Value  |            |-------|-------|   |
	//    |---------|   |              |----------|--------|            |regName| table |---+
	//    :         :   |              |  "__gc"  |c++func1<---+        +---A---+-------+
	//                  |              +----------|--------+   |        :   |   :       :
	//                  |              | "xxxxx"  |c++func2|   |            |
	//                  |              +----------|--------+   |       metatable_name
	//                  |              :          :        :   |
	//                  |                                      |
	//                  |    +------------------+              |
	//                  +--->| allocated memory |        c++ Destructor
	//                       +------------------+
	//
	luaL_getmetatable(L, "lm__C__");

	//                             metatable
	//       stack              +--------------+   +----------------------------------------+
	//    |---------|           |              |   |                       registry         |
	//  -1|userdata |---+       |              V   V                    +-------+-------+   |
	//    |---------|   |       |      +----------+--------+            | Key   | Value |   |
	//    |   v1    |   |       |      |   Key    | Value  |            |-------|-------|   |
	//    |---------|   |       |      |----------|--------|            |regName| table |---+
	//    :         :   |       |      |  "__gc"  |c++func1<---+        +---A---+-------+
	//                  |       |      +----------|--------+   |        :   |   :       :
	//                  |       |      | "xxxxx"  |c++func2|   |            |
	//                  |       |      +----------|--------+   |       metatable_name
	//                  |       |      :          :        :   |
	//                  |       |                              |
	//                  |    +------------------+              |
	//                  +--->| allocated memory |        c++ Destructor
	//                       +------------------+
	//
	::lua_setmetatable(L, -2);
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6054)
/// <summary>
/// Pushes ::CStickTestDlg value on Lua stack.
/// </summary>
template<>
void Sticklib::push_lvalue<::CStickTestDlg*>(lua_State * L, ::CStickTestDlg * const & value, bool own)
{
	//                   Premise.
	//       stack
	//    +---------+
	//  -1|   v1    |
	//    |---------|
	//    :         :
	//

	//       stack
	//    |---------|            +------------------+
	//  -1|userdata |----------->| allocated memory |
	//    |---------|            +------------------+
	//  -2|   v1    |
	//    |---------|            |------------------|
	//    :         :          sizeof(StickInstanceWrapper)
	//
	auto ptr = (StickInstanceWrapper *)lua_newuserdata(L, sizeof(StickInstanceWrapper));
	ptr->own = own;
	ptr->ptr = value;

	//       stack
	//    |---------|
	//  -1|metatable|--------------------------+   +----------------------------------------+
	//    |---------|                          |   |                       registry         |
	//  -2|userdata |---+                      V   V                    +-------+-------+   |
	//    |---------|   |              +----------+--------+            | Key   | Value |   |
	//    |   v1    |   |              |   Key    | Value  |            |-------|-------|   |
	//    |---------|   |              |----------|--------|            |regName| table |---+
	//    :         :   |              |  "__gc"  |c++func1<---+        +---A---+-------+
	//                  |              +----------|--------+   |        :   |   :       :
	//                  |              | "xxxxx"  |c++func2|   |            |
	//                  |              +----------|--------+   |       metatable_name
	//                  |              :          :        :   |
	//                  |                                      |
	//                  |    +------------------+              |
	//                  +--->| allocated memory |        c++ Destructor
	//                       +------------------+
	//
	luaL_getmetatable(L, "lm__CStickTestDlg__");

	//                             metatable
	//       stack              +--------------+   +----------------------------------------+
	//    |---------|           |              |   |                       registry         |
	//  -1|userdata |---+       |              V   V                    +-------+-------+   |
	//    |---------|   |       |      +----------+--------+            | Key   | Value |   |
	//    |   v1    |   |       |      |   Key    | Value  |            |-------|-------|   |
	//    |---------|   |       |      |----------|--------|            |regName| table |---+
	//    :         :   |       |      |  "__gc"  |c++func1<---+        +---A---+-------+
	//                  |       |      +----------|--------+   |        :   |   :       :
	//                  |       |      | "xxxxx"  |c++func2|   |            |
	//                  |       |      +----------|--------+   |       metatable_name
	//                  |       |      :          :        :   |
	//                  |       |                              |
	//                  |    +------------------+              |
	//                  +--->| allocated memory |        c++ Destructor
	//                       +------------------+
	//
	::lua_setmetatable(L, -2);
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6148)
/// <summary>
/// ::X::~X()
/// </summary>
static int lm__X__Destructor(lua_State* L)
{
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Get the class object.
		auto __wrapper = (StickInstanceWrapper*)Sticklib::test_classobject(L, 1, "lm__X__");
		if (__wrapper->own && __wrapper->ptr != nullptr)
		{
			delete (::X*)__wrapper->ptr;
			__wrapper->ptr = nullptr;
		}
	}
	catch (std::exception & e)
	{
		luaL_error(L, (std::string("C function error:::X::~X:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::~X");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6148)
/// <summary>
/// ::X::A::~A()
/// </summary>
static int lm__X__A__Destructor(lua_State* L)
{
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Get the class object.
		auto __wrapper = (StickInstanceWrapper*)Sticklib::test_classobject(L, 1, "lm__X__A__");
		if (__wrapper->own && __wrapper->ptr != nullptr)
		{
			delete (::X::A*)__wrapper->ptr;
			__wrapper->ptr = nullptr;
		}
	}
	catch (std::exception & e)
	{
		luaL_error(L, (std::string("C function error:::X::A::~A:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::A::~A");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6148)
/// <summary>
/// ::X::B::~B()
/// </summary>
static int lm__X__B__Destructor(lua_State* L)
{
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Get the class object.
		auto __wrapper = (StickInstanceWrapper*)Sticklib::test_classobject(L, 1, "lm__X__B__");
		if (__wrapper->own && __wrapper->ptr != nullptr)
		{
			delete (::X::B*)__wrapper->ptr;
			__wrapper->ptr = nullptr;
		}
	}
	catch (std::exception & e)
	{
		luaL_error(L, (std::string("C function error:::X::B::~B:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::B::~B");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6148)
/// <summary>
/// ::NM1::NM1_NM2::~NM1_NM2()
/// </summary>
static int lm__NM1__NM1_NM2__Destructor(lua_State* L)
{
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Get the class object.
		auto __wrapper = (StickInstanceWrapper*)Sticklib::test_classobject(L, 1, "lm__NM1__NM1_NM2__");
		if (__wrapper->own && __wrapper->ptr != nullptr)
		{
			delete (::NM1::NM1_NM2*)__wrapper->ptr;
			__wrapper->ptr = nullptr;
		}
	}
	catch (std::exception & e)
	{
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM2::~NM1_NM2:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM2::~NM1_NM2");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6148)
/// <summary>
/// ::NM1::NM1_NM3::~NM1_NM3()
/// </summary>
static int lm__NM1__NM1_NM3__Destructor(lua_State* L)
{
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Get the class object.
		auto __wrapper = (StickInstanceWrapper*)Sticklib::test_classobject(L, 1, "lm__NM1__NM1_NM3__");
		if (__wrapper->own && __wrapper->ptr != nullptr)
		{
			delete (::NM1::NM1_NM3*)__wrapper->ptr;
			__wrapper->ptr = nullptr;
		}
	}
	catch (std::exception & e)
	{
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM3::~NM1_NM3:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM3::~NM1_NM3");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6148)
/// <summary>
/// ::C::~C()
/// </summary>
static int lm__C__Destructor(lua_State* L)
{
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Get the class object.
		auto __wrapper = (StickInstanceWrapper*)Sticklib::test_classobject(L, 1, "lm__C__");
		if (__wrapper->own && __wrapper->ptr != nullptr)
		{
			delete (::C*)__wrapper->ptr;
			__wrapper->ptr = nullptr;
		}
	}
	catch (std::exception & e)
	{
		luaL_error(L, (std::string("C function error:::C::~C:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::C::~C");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6148)
/// <summary>
/// ::CStickTestDlg::~CStickTestDlg()
/// </summary>
static int lm__CStickTestDlg__Destructor(lua_State* L)
{
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Get the class object.
		auto __wrapper = (StickInstanceWrapper*)Sticklib::test_classobject(L, 1, "lm__CStickTestDlg__");
		if (__wrapper->own && __wrapper->ptr != nullptr)
		{
			delete (::CStickTestDlg*)__wrapper->ptr;
			__wrapper->ptr = nullptr;
		}
	}
	catch (std::exception & e)
	{
		luaL_error(L, (std::string("C function error:::CStickTestDlg::~CStickTestDlg:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::CStickTestDlg::~CStickTestDlg");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::MyArrayFunc0(std::vector<std::string>& v1)
/// </summary>
static int lm__MyArrayFunc0__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		std::vector<std::string> v1;
		Sticklib::check_array<std::string>(v1, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4422)
		// Call the c++ function.
		::MyArrayFunc0((std::vector<std::string>&)v1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_array<std::string>(L, v1, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::MyArrayFunc0:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::MyArrayFunc0");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::MyArrayFunc1(std::vector<int>& v1)
/// </summary>
static int lm__MyArrayFunc1__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		std::vector<__int64> _argin_1_1;
		Sticklib::check_array<__int64>(_argin_1_1, L, 1);
		std::vector<int> v1;
		Sticklib::vectorT_to_vectorU<int,__int64>(v1, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4422)
		// Call the c++ function.
		::MyArrayFunc1((std::vector<int>&)v1);
		std::vector<__int64> _argout_1_1;
		Sticklib::vectorT_to_vectorU<__int64,int>(_argout_1_1, v1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_array<__int64>(L, _argout_1_1, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::MyArrayFunc1:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::MyArrayFunc1");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::MyArrayFunc2(std::vector<std::wstring>& v1)
/// </summary>
static int lm__MyArrayFunc2__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		std::vector<std::string> _argin_1_1;
		Sticklib::check_array<std::string>(_argin_1_1, L, 1);
		std::vector<std::wstring> v1;
		Sticklib::vectorT_to_vectorU<std::wstring,std::string>(v1, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4422)
		// Call the c++ function.
		::MyArrayFunc2((std::vector<std::wstring>&)v1);
		std::vector<std::string> _argout_1_1;
		Sticklib::vectorT_to_vectorU<std::string,std::wstring>(_argout_1_1, v1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_array<std::string>(L, _argout_1_1, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::MyArrayFunc2:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::MyArrayFunc2");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::MyFunc1(std::wstring& wstr1, wchar_t* wcp2)
/// </summary>
static int lm__MyFunc1__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		std::string _argin_1_1;
		Sticklib::check_lvalue<std::string>(_argin_1_1, L, 1);
		std::wstring wstr1;
		Sticklib::T_to_U<std::wstring, std::string>(wstr1, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		std::string _argin_2_1;
		Sticklib::check_lvalue<std::string>(_argin_2_1, L, 2);
		std::wstring _argin_2_2;
		Sticklib::T_to_U<std::wstring, std::string>(_argin_2_2, _argin_2_1);
		wchar_t* wcp2;
		Sticklib::T_to_U<wchar_t*,std::wstring>(wcp2, _argin_2_2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4436)
		// Call the c++ function.
		auto __lstickvar_ret = (std::wstring)::MyFunc1((std::wstring&)wstr1, (const wchar_t*)wcp2);
		std::string _argout_0_1;
		Sticklib::Sticklib::T_to_U<std::string, std::wstring>(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<std::string>(L, _argout_0_1, false);
		std::string _argout_1_1;
		Sticklib::Sticklib::T_to_U<std::string, std::wstring>(_argout_1_1, wstr1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<std::string>(L, _argout_1_1, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::MyFunc1:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::MyFunc1");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::MyFunc2(double& v1, __int64 v2)
/// </summary>
static int lm__MyFunc2__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		double v1;
		Sticklib::check_lvalue<double>(v1, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		__int64 v2;
		Sticklib::check_lvalue<__int64>(v2, L, 2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4436)
		// Call the c++ function.
		auto __lstickvar_ret = (int)::MyFunc2((double&)v1, (__int64)v2);
		__int64 _argout_0_1;
		Sticklib::T_to_U<__int64,int>(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<__int64>(L, _argout_0_1, false);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<double>(L, v1, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::MyFunc2:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::MyFunc2");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::ShowMessage(wchar_t* text)
/// </summary>
static int lm__ShowMessage__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		std::string _argin_1_1;
		Sticklib::check_lvalue<std::string>(_argin_1_1, L, 1);
		std::wstring _argin_1_2;
		Sticklib::T_to_U<std::wstring, std::string>(_argin_1_2, _argin_1_1);
		wchar_t* text;
		Sticklib::T_to_U<wchar_t*,std::wstring>(text, _argin_1_2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4422)
		// Call the c++ function.
		::ShowMessage((const wchar_t*)text);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::ShowMessage:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::ShowMessage");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::ToStickTestDlg(void* data)
/// </summary>
static int lm__ToStickTestDlg__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		void* data;
		Sticklib::check_lvalue<void*>(data, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4436)
		// Call the c++ function.
		auto __lstickvar_ret = (::CStickTestDlg*)::ToStickTestDlg((void*)data);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<::CStickTestDlg*>(L, __lstickvar_ret, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::ToStickTestDlg:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::ToStickTestDlg");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::X::X()
/// </summary>
static int lm__X__New__0(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 0)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4446)
		// Create the class object and give back it to lua.
		auto obj = new ::X();
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4476)
		Sticklib::push_lvalue<::X*>(L, obj, true);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::X::X:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::X");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::X::A::FuncX(::X::Enum1& x)
/// </summary>
static int lm__X__A__FuncX__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4252)
		// Get the class object.
		::X::A * __lstickobj;
		Sticklib::check_lvalue<::X::A*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		__int64 _argin_1_1;
		Sticklib::check_lvalue<__int64>(_argin_1_1, L, 2);
		::X::Enum1 x;
		Sticklib::T_to_U<::X::Enum1, __int64>(x, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4392)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		__lstickobj->FuncX((enum class ::X::Enum1&)x);
		__int64 _argout_1_1;
		Sticklib::T_to_U<__int64, ::X::Enum1>(_argout_1_1, x);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<__int64>(L, _argout_1_1, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::X::A::FuncX:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::A::FuncX");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::X::A::Get()
/// </summary>
static int lm__X__A__Get__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4252)
		// Get the class object.
		::X::A * __lstickobj;
		Sticklib::check_lvalue<::X::A*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4409)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		auto __lstickvar_ret = (int)__lstickobj->Get();
		__int64 _argout_0_1;
		Sticklib::T_to_U<__int64,int>(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<__int64>(L, _argout_0_1, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::X::A::Get:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::A::Get");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::X::A::GetSet(int* a)
/// </summary>
static int lm__X__A__GetSet__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4252)
		// Get the class object.
		::X::A * __lstickobj;
		Sticklib::check_lvalue<::X::A*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4363)
		int _argin_1_1;
		int* a = &_argin_1_1;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4392)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		__lstickobj->GetSet((int*)a);
		int& _argout_1_1 = *a;
		__int64 _argout_1_2;
		Sticklib::T_to_U<__int64,int>(_argout_1_2, _argout_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<__int64>(L, _argout_1_2, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::X::A::GetSet:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::A::GetSet");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::X::A::Set(int a)
/// </summary>
static int lm__X__A__Set__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4252)
		// Get the class object.
		::X::A * __lstickobj;
		Sticklib::check_lvalue<::X::A*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		__int64 _argin_1_1;
		Sticklib::check_lvalue<__int64>(_argin_1_1, L, 2);
		int a;
		Sticklib::T_to_U<int,__int64>(a, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4392)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		__lstickobj->Set((int)a);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::X::A::Set:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::A::Set");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::X::A::Set(int a, int b)
/// </summary>
static int lm__X__A__Set__3(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 3)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4252)
		// Get the class object.
		::X::A * __lstickobj;
		Sticklib::check_lvalue<::X::A*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		__int64 _argin_1_1;
		Sticklib::check_lvalue<__int64>(_argin_1_1, L, 2);
		int a;
		Sticklib::T_to_U<int,__int64>(a, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		__int64 _argin_2_1;
		Sticklib::check_lvalue<__int64>(_argin_2_1, L, 3);
		int b;
		Sticklib::T_to_U<int,__int64>(b, _argin_2_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4392)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		__lstickobj->Set((int)a, (int)b);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::X::A::Set:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::A::Set");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::X::A::New(int a)
/// </summary>
static int lm__X__A__New__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		__int64 _argin_1_1;
		Sticklib::check_lvalue<__int64>(_argin_1_1, L, 1);
		int a;
		Sticklib::T_to_U<int,__int64>(a, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4446)
		// Create the class object and give back it to lua.
		auto obj = new ::X::A((int)a);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4476)
		Sticklib::push_lvalue<::X::A*>(L, obj, true);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::X::A::New:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::A::New");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::X::B::Add1(::X::A*& a)
/// </summary>
static int lm__X__B__Add1__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4252)
		// Get the class object.
		::X::B * __lstickobj;
		Sticklib::check_lvalue<::X::B*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4374)
		::X::A* a;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4409)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		auto __lstickvar_ret = (int)__lstickobj->Add1((::X::A*&)a);
		__int64 _argout_0_1;
		Sticklib::T_to_U<__int64,int>(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<__int64>(L, _argout_0_1, false);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<::X::A*>(L, a, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::X::B::Add1:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::B::Add1");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::X::B::Add2(::X::A* a)
/// </summary>
static int lm__X__B__Add2__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4252)
		// Get the class object.
		::X::B * __lstickobj;
		Sticklib::check_lvalue<::X::B*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		::X::A* a;
		Sticklib::check_lvalue<::X::A*>(a, L, 2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4392)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		__lstickobj->Add2((class ::X::A*)a);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::X::B::Add2:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::B::Add2");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::X::B::CreateA(int a)
/// </summary>
static int lm__X__B__CreateA__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		__int64 _argin_1_1;
		Sticklib::check_lvalue<__int64>(_argin_1_1, L, 1);
		int a;
		Sticklib::T_to_U<int,__int64>(a, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4436)
		// Call the c++ function.
		auto __lstickvar_ret = (::X::A*)::X::B::CreateA((int)a);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<::X::A*>(L, __lstickvar_ret, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::X::B::CreateA:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::B::CreateA");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::X::B::DeleteA(::X::A* a)
/// </summary>
static int lm__X__B__DeleteA__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		::X::A* a;
		Sticklib::check_lvalue<::X::A*>(a, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4422)
		// Call the c++ function.
		::X::B::DeleteA((::X::A*)a);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::X::B::DeleteA:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::B::DeleteA");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::X::B::B()
/// </summary>
static int lm__X__B__New__0(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 0)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4446)
		// Create the class object and give back it to lua.
		auto obj = new ::X::B();
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4476)
		Sticklib::push_lvalue<::X::B*>(L, obj, true);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::X::B::B:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::B::B");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::NM1::MyFunc2(double& v1, __int64 v2)
/// </summary>
static int lm__NM1__MyFunc2__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		double v1;
		Sticklib::check_lvalue<double>(v1, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		__int64 v2;
		Sticklib::check_lvalue<__int64>(v2, L, 2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4436)
		// Call the c++ function.
		auto __lstickvar_ret = (int)::NM1::MyFunc2((double&)v1, (__int64)v2);
		__int64 _argout_0_1;
		Sticklib::T_to_U<__int64,int>(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<__int64>(L, _argout_0_1, false);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<double>(L, v1, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::NM1::MyFunc2:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::MyFunc2");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::NM1::NM1_NM1::MyFunc0(void* array)
/// </summary>
static int lm__NM1__NM1_NM1__MyFunc0__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		void* array;
		Sticklib::check_lvalue<void*>(array, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4422)
		// Call the c++ function.
		::NM1::NM1_NM1::MyFunc0((const int*)array);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM1::MyFunc0:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM1::MyFunc0");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::NM1::NM1_NM1::MyFunc1(std::wstring& wstr1, wchar_t* wcp2)
/// </summary>
static int lm__NM1__NM1_NM1__MyFunc1__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		std::string _argin_1_1;
		Sticklib::check_lvalue<std::string>(_argin_1_1, L, 1);
		std::wstring wstr1;
		Sticklib::T_to_U<std::wstring, std::string>(wstr1, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		std::string _argin_2_1;
		Sticklib::check_lvalue<std::string>(_argin_2_1, L, 2);
		std::wstring _argin_2_2;
		Sticklib::T_to_U<std::wstring, std::string>(_argin_2_2, _argin_2_1);
		wchar_t* wcp2;
		Sticklib::T_to_U<wchar_t*,std::wstring>(wcp2, _argin_2_2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4436)
		// Call the c++ function.
		auto __lstickvar_ret = (std::wstring)::NM1::NM1_NM1::MyFunc1((std::wstring&)wstr1, (const wchar_t*)wcp2);
		std::string _argout_0_1;
		Sticklib::Sticklib::T_to_U<std::string, std::wstring>(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<std::string>(L, _argout_0_1, false);
		std::string _argout_1_1;
		Sticklib::Sticklib::T_to_U<std::string, std::wstring>(_argout_1_1, wstr1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<std::string>(L, _argout_1_1, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM1::MyFunc1:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM1::MyFunc1");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::NM1::NM1_NM1::MyFunc2(std::string& v1)
/// </summary>
static int lm__NM1__NM1_NM1__MyFunc2x__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		std::string v1;
		Sticklib::check_lvalue<std::string>(v1, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4436)
		// Call the c++ function.
		auto __lstickvar_ret = (int)::NM1::NM1_NM1::MyFunc2((std::string&)v1);
		__int64 _argout_0_1;
		Sticklib::T_to_U<__int64,int>(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<__int64>(L, _argout_0_1, false);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<std::string>(L, v1, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM1::MyFunc2:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM1::MyFunc2");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::NM1::NM1_NM1::MyFunc2(double& v1)
/// </summary>
static int lm__NM1__NM1_NM1__MyFunc2y__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		double v1;
		Sticklib::check_lvalue<double>(v1, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4436)
		// Call the c++ function.
		auto __lstickvar_ret = (int)::NM1::NM1_NM1::MyFunc2((double&)v1);
		__int64 _argout_0_1;
		Sticklib::T_to_U<__int64,int>(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<__int64>(L, _argout_0_1, false);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<double>(L, v1, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM1::MyFunc2:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM1::MyFunc2");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::NM1::NM1_NM1::MyFunc2(double& v1, __int64 v2)
/// </summary>
static int lm__NM1__NM1_NM1__MyFunc2y__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		double v1;
		Sticklib::check_lvalue<double>(v1, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		__int64 v2;
		Sticklib::check_lvalue<__int64>(v2, L, 2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4436)
		// Call the c++ function.
		auto __lstickvar_ret = (int)::NM1::NM1_NM1::MyFunc2((double&)v1, (__int64)v2);
		__int64 _argout_0_1;
		Sticklib::T_to_U<__int64,int>(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<__int64>(L, _argout_0_1, false);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<double>(L, v1, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM1::MyFunc2:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM1::MyFunc2");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::NM1::NM1_NM2::MyFunc2(double& v1, __int64 v2)
/// </summary>
static int lm__NM1__NM1_NM2__MyFunc2__3(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 3)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4252)
		// Get the class object.
		::NM1::NM1_NM2 * __lstickobj;
		Sticklib::check_lvalue<::NM1::NM1_NM2*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		double v1;
		Sticklib::check_lvalue<double>(v1, L, 2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		__int64 v2;
		Sticklib::check_lvalue<__int64>(v2, L, 3);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4409)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		auto __lstickvar_ret = (int)__lstickobj->MyFunc2((double&)v1, (__int64)v2);
		__int64 _argout_0_1;
		Sticklib::T_to_U<__int64,int>(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<__int64>(L, _argout_0_1, false);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<double>(L, v1, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM2::MyFunc2:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM2::MyFunc2");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::NM1::NM1_NM2::New()
/// </summary>
static int lm__NM1__NM1_NM2__New__0(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 0)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4446)
		// Create the class object and give back it to lua.
		auto obj = new ::NM1::NM1_NM2();
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4476)
		Sticklib::push_lvalue<::NM1::NM1_NM2*>(L, obj, true);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM2::New:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM2::New");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::NM1::NM1_NM2::New(int& a)
/// </summary>
static int lm__NM1__NM1_NM2__New__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		__int64 _argin_1_1;
		Sticklib::check_lvalue<__int64>(_argin_1_1, L, 1);
		int a;
		Sticklib::T_to_U<int,__int64>(a, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4446)
		// Create the class object and give back it to lua.
		auto obj = new ::NM1::NM1_NM2((int&)a);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4476)
		Sticklib::push_lvalue<::NM1::NM1_NM2*>(L, obj, true);
		__int64 _argout_1_1;
		Sticklib::T_to_U<__int64,int>(_argout_1_1, a);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<__int64>(L, _argout_1_1, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM2::New:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM2::New");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::NM1::NM1_NM3::MyFunc3(double& v1)
/// </summary>
static int lm__NM1__NM1_NM3__MyFunc3__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4252)
		// Get the class object.
		::NM1::NM1_NM3 * __lstickobj;
		Sticklib::check_lvalue<::NM1::NM1_NM3*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		double v1;
		Sticklib::check_lvalue<double>(v1, L, 2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4409)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		auto __lstickvar_ret = (int)__lstickobj->MyFunc3((double&)v1);
		__int64 _argout_0_1;
		Sticklib::T_to_U<__int64,int>(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<__int64>(L, _argout_0_1, false);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<double>(L, v1, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM3::MyFunc3:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM3::MyFunc3");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::NM1::NM1_NM3::MyFunc3(double& v1, __int64 v2)
/// </summary>
static int lm__NM1__NM1_NM3__MyFunc3__3(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 3)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4252)
		// Get the class object.
		::NM1::NM1_NM3 * __lstickobj;
		Sticklib::check_lvalue<::NM1::NM1_NM3*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		double v1;
		Sticklib::check_lvalue<double>(v1, L, 2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		__int64 v2;
		Sticklib::check_lvalue<__int64>(v2, L, 3);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4409)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		auto __lstickvar_ret = (int)__lstickobj->MyFunc3((double&)v1, (__int64)v2);
		__int64 _argout_0_1;
		Sticklib::T_to_U<__int64,int>(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<__int64>(L, _argout_0_1, false);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<double>(L, v1, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM3::MyFunc3:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM3::MyFunc3");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::NM1::NM1_NM3::NM1_NM3()
/// </summary>
static int lm__NM1__NM1_NM3__New__0(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 0)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4446)
		// Create the class object and give back it to lua.
		auto obj = new ::NM1::NM1_NM3();
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4476)
		Sticklib::push_lvalue<::NM1::NM1_NM3*>(L, obj, true);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM3::NM1_NM3:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM3::NM1_NM3");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::C::C()
/// </summary>
static int lm__C__New__0(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 0)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4446)
		// Create the class object and give back it to lua.
		auto obj = new ::C();
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4476)
		Sticklib::push_lvalue<::C*>(L, obj, true);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::C::C:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::C::C");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::NM2::MyFunc2(double& v1, __int64 v2)
/// </summary>
static int lm__NM2__MyFunc2__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		double v1;
		Sticklib::check_lvalue<double>(v1, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		__int64 v2;
		Sticklib::check_lvalue<__int64>(v2, L, 2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4436)
		// Call the c++ function.
		auto __lstickvar_ret = (int)::NM2::MyFunc2((double&)v1, (__int64)v2);
		__int64 _argout_0_1;
		Sticklib::T_to_U<__int64,int>(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<__int64>(L, _argout_0_1, false);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<double>(L, v1, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::NM2::MyFunc2:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM2::MyFunc2");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::CStickTestDlg::DebugOutput(char* message)
/// </summary>
static int lm__CStickTestDlg__DebugOutput__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4252)
		// Get the class object.
		::CStickTestDlg * __lstickobj;
		Sticklib::check_lvalue<::CStickTestDlg*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		std::string _argin_1_1;
		Sticklib::check_lvalue<std::string>(_argin_1_1, L, 2);
		char* message;
		Sticklib::T_to_U<char *, std::string>(message, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4392)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		__lstickobj->DebugOutput((const char*)message);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::CStickTestDlg::DebugOutput:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::CStickTestDlg::DebugOutput");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::CStickTestDlg::CStickTestDlg()
/// </summary>
static int lm__CStickTestDlg__New__0(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 0)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4446)
		// Create the class object and give back it to lua.
		auto obj = new ::CStickTestDlg();
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4476)
		Sticklib::push_lvalue<::CStickTestDlg*>(L, obj, true);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::CStickTestDlg::CStickTestDlg:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::CStickTestDlg::CStickTestDlg");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7380)
/// <summary>
/// X.A.Set(...)
/// Distribute the process to the polymorphic functions. X.A.Set(...)
/// </summary>
static int lm__X__A__Set(lua_State* L)
{
	switch (lua_gettop(L))
	{
	case 2:
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7393)
		return lm__X__A__Set__2(L);
	case 3:
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7393)
		return lm__X__A__Set__3(L);
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7403)
	default:
		luaL_error(L, "incorrect argument");
		return 0;
	}
}
// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7380)
/// <summary>
/// NM1.MMM1.MyFunc2y(...)
/// Distribute the process to the polymorphic functions. NM1.MMM1.MyFunc2y(...)
/// </summary>
static int lm__NM1__NM1_NM1__MyFunc2y(lua_State* L)
{
	switch (lua_gettop(L))
	{
	case 1:
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7393)
		return lm__NM1__NM1_NM1__MyFunc2y__1(L);
	case 2:
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7393)
		return lm__NM1__NM1_NM1__MyFunc2y__2(L);
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7403)
	default:
		luaL_error(L, "incorrect argument");
		return 0;
	}
}
// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7380)
/// <summary>
/// NM1.NM1_NM2.New(...)
/// Distribute the process to the polymorphic functions. NM1.NM1_NM2.New(...)
/// </summary>
static int lm__NM1__NM1_NM2__New(lua_State* L)
{
	switch (lua_gettop(L))
	{
	case 0:
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7393)
		return lm__NM1__NM1_NM2__New__0(L);
	case 1:
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7393)
		return lm__NM1__NM1_NM2__New__1(L);
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7403)
	default:
		luaL_error(L, "incorrect argument");
		return 0;
	}
}
// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7380)
/// <summary>
/// NM1.NM1_NM3.MyFunc3(...)
/// Distribute the process to the polymorphic functions. NM1.NM1_NM3.MyFunc3(...)
/// </summary>
static int lm__NM1__NM1_NM3__MyFunc3(lua_State* L)
{
	switch (lua_gettop(L))
	{
	case 2:
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7393)
		return lm__NM1__NM1_NM3__MyFunc3__2(L);
	case 3:
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7393)
		return lm__NM1__NM1_NM3__MyFunc3__3(L);
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7403)
	default:
		luaL_error(L, "incorrect argument");
		return 0;
	}
}
// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8730)
/// <summary>
/// LuaStick initializing function.
/// luastick_init must be called to register the classes and its member functions.
/// </summary>
void luastick_init(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7623)
	// Register the global functions.
	Sticklib::push_table(L, "");
	{
		static struct luaL_Reg lm__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7642)
			{ "MyArrayFunc0", lm__MyArrayFunc0__1 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7642)
			{ "MyArrayFunc1", lm__MyArrayFunc1__1 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7642)
			{ "MyArrayFunc2", lm__MyArrayFunc2__1 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7642)
			{ "MyFunc1", lm__MyFunc1__2 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7642)
			{ "MyFunc2", lm__MyFunc2__2 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7642)
			{ "ShowMessage", lm__ShowMessage__1 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7642)
			{ "ToStickTestDlg", lm__ToStickTestDlg__1 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7653)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7728)
	// Register the constants in the static class ''
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7752)
		int& _var_1_1 = (int&)::HIJ;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7775)
		__int64 _var_1_2;
		Sticklib::T_to_U<__int64,int>(_var_1_2, _var_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7833)
		Sticklib::set_lvalue_to_table<__int64>(L, "HIJ", _var_1_2, false);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7752)
		::X::B*& _var_2_1 = (::X::B*&)::XXBB;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7833)
		Sticklib::set_lvalue_to_table<::X::B*>(L, "XXBB", _var_2_1, false);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7752)
		char* _var_3_1 = (char*)XXX;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7775)
		std::string _var_3_2;
		Sticklib::T_to_U<std::string, char *>(_var_3_2, _var_3_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7833)
		Sticklib::set_lvalue_to_table<std::string>(L, "XXX", _var_3_2, false);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7623)
	// Register the static class '::X' and its static member functions.
	Sticklib::push_table(L, "X");
	{
		static struct luaL_Reg lm__X__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7642)
			{ "New", lm__X__New__0 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7653)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__X__Static);
	}

	// Register the enumeration in the static class '::X'

	// Register the enumeration in the static class '::X'
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7681)
	Sticklib::push_table(L, "Enum1");
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7698)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7728)
	// Register the constants in the static class '::X'
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7752)
		int& _var_1_1 = (int&)::X::EFG;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7775)
		__int64 _var_1_2;
		Sticklib::T_to_U<__int64,int>(_var_1_2, _var_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7833)
		Sticklib::set_lvalue_to_table<__int64>(L, "EFG", _var_1_2, false);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7865)
	// Register the regular class '::X' and its regular member functions.
	static struct luaL_Reg lm__X__Method[] =
	{
		{ "__gc", lm__X__Destructor },
		{ nullptr, nullptr },
	};
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7911)
	Sticklib::register_class(L, "lm__X__", lm__X__Method, nullptr);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7623)
	// Register the static class '::X::A' and its static member functions.
	Sticklib::push_table(L, "A");
	{
		static struct luaL_Reg lm__X__A__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7642)
			{ "New", lm__X__A__New__1 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7653)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__X__A__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7728)
	// Register the constants in the static class '::X::A'
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7752)
		char*& _var_1_1 = (char*&)::X::A::ABC;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7775)
		std::string _var_1_2;
		Sticklib::T_to_U<std::string, char *>(_var_1_2, _var_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7833)
		Sticklib::set_lvalue_to_table<std::string>(L, "ABC", _var_1_2, false);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7752)
		int& _var_2_1 = (int&)::X::A::EFG;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7775)
		__int64 _var_2_2;
		Sticklib::T_to_U<__int64,int>(_var_2_2, _var_2_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7833)
		Sticklib::set_lvalue_to_table<__int64>(L, "EFG", _var_2_2, false);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7865)
	// Register the regular class '::X::A' and its regular member functions.
	static struct luaL_Reg lm__X__A__Method[] =
	{
		{ "__gc", lm__X__A__Destructor },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7893)
		{ "FuncX", lm__X__A__FuncX__2 },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7893)
		{ "Get", lm__X__A__Get__1 },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7893)
		{ "GetSet", lm__X__A__GetSet__1 },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7893)
		{ "Set", lm__X__A__Set },
		{ nullptr, nullptr },
	};
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7911)
	Sticklib::register_class(L, "lm__X__A__", lm__X__A__Method, nullptr);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7934)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7623)
	// Register the static class '::X::B' and its static member functions.
	Sticklib::push_table(L, "B");
	{
		static struct luaL_Reg lm__X__B__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7642)
			{ "CreateA", lm__X__B__CreateA__1 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7642)
			{ "DeleteA", lm__X__B__DeleteA__1 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7642)
			{ "New", lm__X__B__New__0 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7653)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__X__B__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7865)
	// Register the regular class '::X::B' and its regular member functions.
	static struct luaL_Reg lm__X__B__Method[] =
	{
		{ "__gc", lm__X__B__Destructor },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7893)
		{ "Add1", lm__X__B__Add1__1 },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7893)
		{ "Add2", lm__X__B__Add2__2 },
		{ nullptr, nullptr },
	};
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7911)
	Sticklib::register_class(L, "lm__X__B__", lm__X__B__Method, nullptr);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7934)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7934)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7623)
	// Register the static class '::NM1' and its static member functions.
	Sticklib::push_table(L, "NM1");
	{
		static struct luaL_Reg lm__NM1__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7642)
			{ "MyFunc2", lm__NM1__MyFunc2__2 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7653)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__NM1__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7623)
	// Register the static class '::NM1::NM1_NM1' and its static member functions.
	Sticklib::push_table(L, "MMM1");
	{
		static struct luaL_Reg lm__NM1__NM1_NM1__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7642)
			{ "MyFunc0", lm__NM1__NM1_NM1__MyFunc0__1 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7642)
			{ "MyFunc1", lm__NM1__NM1_NM1__MyFunc1__2 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7642)
			{ "MyFunc2x", lm__NM1__NM1_NM1__MyFunc2x__1 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7642)
			{ "MyFunc2y", lm__NM1__NM1_NM1__MyFunc2y },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7653)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__NM1__NM1_NM1__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7728)
	// Register the constants in the static class '::NM1::NM1_NM1'
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7752)
		void*& _var_1_1 = (void*&)::NM1::NM1_NM1::ARRAY;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7833)
		Sticklib::set_lvalue_to_table<void*>(L, "ARRAY", _var_1_1, false);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7934)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7623)
	// Register the static class '::NM1::NM1_NM2' and its static member functions.
	Sticklib::push_table(L, "NM1_NM2");
	{
		static struct luaL_Reg lm__NM1__NM1_NM2__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7642)
			{ "New", lm__NM1__NM1_NM2__New },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7653)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__NM1__NM1_NM2__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7865)
	// Register the regular class '::NM1::NM1_NM2' and its regular member functions.
	static struct luaL_Reg lm__NM1__NM1_NM2__Method[] =
	{
		{ "__gc", lm__NM1__NM1_NM2__Destructor },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7893)
		{ "MyFunc2", lm__NM1__NM1_NM2__MyFunc2__3 },
		{ nullptr, nullptr },
	};
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7911)
	Sticklib::register_class(L, "lm__NM1__NM1_NM2__", lm__NM1__NM1_NM2__Method, nullptr);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7934)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7623)
	// Register the static class '::NM1::NM1_NM3' and its static member functions.
	Sticklib::push_table(L, "NM1_NM3");
	{
		static struct luaL_Reg lm__NM1__NM1_NM3__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7642)
			{ "New", lm__NM1__NM1_NM3__New__0 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7653)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__NM1__NM1_NM3__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7865)
	// Register the regular class '::NM1::NM1_NM3' and its regular member functions.
	static struct luaL_Reg lm__NM1__NM1_NM3__Method[] =
	{
		{ "__gc", lm__NM1__NM1_NM3__Destructor },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7893)
		{ "MyFunc3", lm__NM1__NM1_NM3__MyFunc3 },
		{ nullptr, nullptr },
	};
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7920)
	Sticklib::register_class(L, "lm__NM1__NM1_NM3__", lm__NM1__NM1_NM3__Method, "lm__NM1__NM1_NM2__");

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7934)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7934)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7623)
	// Register the static class '::C' and its static member functions.
	Sticklib::push_table(L, "C");
	{
		static struct luaL_Reg lm__C__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7642)
			{ "New", lm__C__New__0 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7653)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__C__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7865)
	// Register the regular class '::C' and its regular member functions.
	static struct luaL_Reg lm__C__Method[] =
	{
		{ "__gc", lm__C__Destructor },
		{ nullptr, nullptr },
	};
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7920)
	Sticklib::register_class(L, "lm__C__", lm__C__Method, "lm__NM1__NM1_NM3__");

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7934)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7623)
	// Register the static class '::NM2' and its static member functions.
	Sticklib::push_table(L, "NM2");
	{
		static struct luaL_Reg lm__NM2__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7642)
			{ "MyFunc2", lm__NM2__MyFunc2__2 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7653)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__NM2__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7934)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7623)
	// Register the static class '::CStickTestDlg' and its static member functions.
	Sticklib::push_table(L, "CStickTestDlg");
	{
		static struct luaL_Reg lm__CStickTestDlg__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7642)
			{ "New", lm__CStickTestDlg__New__0 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7653)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__CStickTestDlg__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7865)
	// Register the regular class '::CStickTestDlg' and its regular member functions.
	static struct luaL_Reg lm__CStickTestDlg__Method[] =
	{
		{ "__gc", lm__CStickTestDlg__Destructor },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7893)
		{ "DebugOutput", lm__CStickTestDlg__DebugOutput__2 },
		{ nullptr, nullptr },
	};
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7911)
	Sticklib::register_class(L, "lm__CStickTestDlg__", lm__CStickTestDlg__Method, nullptr);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7934)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7934)
	Sticklib::pop(L);

}

