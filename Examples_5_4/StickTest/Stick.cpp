// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8773)
// Generated by LuaStick, Jun 11 2021.

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8781)
#include "stdafx.h"
// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8781)
#include "..\..\LuaStick\files\Sticklib.h"
// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8781)
#include "StickTestDlg.h"
// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8798)
#include "Stick.h"
#include <random>

#define XXH_STATIC_LINKING_ONLY   /* access advanced declarations */
#define XXH_IMPLEMENTATION   /* access definitions */

#include "..\..\LuaStick\files\xxhash.h"

// Validation id for StickInstanceWrapper.
static unsigned __int64 WRAPPER_SEED = 0;

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5878)
/// <summary>
/// Gets ::X value from Lua stack.
/// </summary>
template<>
void Sticklib::check_lvalue<::X*>(::X * & value, lua_State * L, int arg)
{
	//        stack
	//     :          :
	//     |----------|            +------------------+
	//  arg| userdata |----------->| allocated memory |
	//     |----------|            +------------------+
	//     :          :
	//                             |------------------|
	//                           sizeof(StickInstanceWrapper)
	//
	// Premise for following.
	//

	// lua_touserdata is valid for userdata and lightuserdata both.
	auto wrapper = (StickInstanceWrapper *)lua_touserdata(L, arg);
	if (!wrapper)
		throw std::invalid_argument("The argument is not userdata nor lightuserdata");
	if (wrapper->hash != XXH64(&wrapper->ptr, sizeof(wrapper->ptr), WRAPPER_SEED))
		throw std::invalid_argument("Invalid class object");
	value = (::X *)wrapper->ptr;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5878)
/// <summary>
/// Gets ::X::A value from Lua stack.
/// </summary>
template<>
void Sticklib::check_lvalue<::X::A*>(::X::A * & value, lua_State * L, int arg)
{
	//        stack
	//     :          :
	//     |----------|            +------------------+
	//  arg| userdata |----------->| allocated memory |
	//     |----------|            +------------------+
	//     :          :
	//                             |------------------|
	//                           sizeof(StickInstanceWrapper)
	//
	// Premise for following.
	//

	// lua_touserdata is valid for userdata and lightuserdata both.
	auto wrapper = (StickInstanceWrapper *)lua_touserdata(L, arg);
	if (!wrapper)
		throw std::invalid_argument("The argument is not userdata nor lightuserdata");
	if (wrapper->hash != XXH64(&wrapper->ptr, sizeof(wrapper->ptr), WRAPPER_SEED))
		throw std::invalid_argument("Invalid class object");
	value = (::X::A *)wrapper->ptr;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5878)
/// <summary>
/// Gets ::X::B value from Lua stack.
/// </summary>
template<>
void Sticklib::check_lvalue<::X::B*>(::X::B * & value, lua_State * L, int arg)
{
	//        stack
	//     :          :
	//     |----------|            +------------------+
	//  arg| userdata |----------->| allocated memory |
	//     |----------|            +------------------+
	//     :          :
	//                             |------------------|
	//                           sizeof(StickInstanceWrapper)
	//
	// Premise for following.
	//

	// lua_touserdata is valid for userdata and lightuserdata both.
	auto wrapper = (StickInstanceWrapper *)lua_touserdata(L, arg);
	if (!wrapper)
		throw std::invalid_argument("The argument is not userdata nor lightuserdata");
	if (wrapper->hash != XXH64(&wrapper->ptr, sizeof(wrapper->ptr), WRAPPER_SEED))
		throw std::invalid_argument("Invalid class object");
	value = (::X::B *)wrapper->ptr;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5878)
/// <summary>
/// Gets ::NM1::NM1_NM2 value from Lua stack.
/// </summary>
template<>
void Sticklib::check_lvalue<::NM1::NM1_NM2*>(::NM1::NM1_NM2 * & value, lua_State * L, int arg)
{
	//        stack
	//     :          :
	//     |----------|            +------------------+
	//  arg| userdata |----------->| allocated memory |
	//     |----------|            +------------------+
	//     :          :
	//                             |------------------|
	//                           sizeof(StickInstanceWrapper)
	//
	// Premise for following.
	//

	// lua_touserdata is valid for userdata and lightuserdata both.
	auto wrapper = (StickInstanceWrapper *)lua_touserdata(L, arg);
	if (!wrapper)
		throw std::invalid_argument("The argument is not userdata nor lightuserdata");
	if (wrapper->hash != XXH64(&wrapper->ptr, sizeof(wrapper->ptr), WRAPPER_SEED))
		throw std::invalid_argument("Invalid class object");
	value = (::NM1::NM1_NM2 *)wrapper->ptr;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5878)
/// <summary>
/// Gets ::NM1::NM1_NM3 value from Lua stack.
/// </summary>
template<>
void Sticklib::check_lvalue<::NM1::NM1_NM3*>(::NM1::NM1_NM3 * & value, lua_State * L, int arg)
{
	//        stack
	//     :          :
	//     |----------|            +------------------+
	//  arg| userdata |----------->| allocated memory |
	//     |----------|            +------------------+
	//     :          :
	//                             |------------------|
	//                           sizeof(StickInstanceWrapper)
	//
	// Premise for following.
	//

	// lua_touserdata is valid for userdata and lightuserdata both.
	auto wrapper = (StickInstanceWrapper *)lua_touserdata(L, arg);
	if (!wrapper)
		throw std::invalid_argument("The argument is not userdata nor lightuserdata");
	if (wrapper->hash != XXH64(&wrapper->ptr, sizeof(wrapper->ptr), WRAPPER_SEED))
		throw std::invalid_argument("Invalid class object");
	value = (::NM1::NM1_NM3 *)wrapper->ptr;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5878)
/// <summary>
/// Gets ::C value from Lua stack.
/// </summary>
template<>
void Sticklib::check_lvalue<::C*>(::C * & value, lua_State * L, int arg)
{
	//        stack
	//     :          :
	//     |----------|            +------------------+
	//  arg| userdata |----------->| allocated memory |
	//     |----------|            +------------------+
	//     :          :
	//                             |------------------|
	//                           sizeof(StickInstanceWrapper)
	//
	// Premise for following.
	//

	// lua_touserdata is valid for userdata and lightuserdata both.
	auto wrapper = (StickInstanceWrapper *)lua_touserdata(L, arg);
	if (!wrapper)
		throw std::invalid_argument("The argument is not userdata nor lightuserdata");
	if (wrapper->hash != XXH64(&wrapper->ptr, sizeof(wrapper->ptr), WRAPPER_SEED))
		throw std::invalid_argument("Invalid class object");
	value = (::C *)wrapper->ptr;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5878)
/// <summary>
/// Gets ::CStickTestDlg value from Lua stack.
/// </summary>
template<>
void Sticklib::check_lvalue<::CStickTestDlg*>(::CStickTestDlg * & value, lua_State * L, int arg)
{
	//        stack
	//     :          :
	//     |----------|            +------------------+
	//  arg| userdata |----------->| allocated memory |
	//     |----------|            +------------------+
	//     :          :
	//                             |------------------|
	//                           sizeof(StickInstanceWrapper)
	//
	// Premise for following.
	//

	// lua_touserdata is valid for userdata and lightuserdata both.
	auto wrapper = (StickInstanceWrapper *)lua_touserdata(L, arg);
	if (!wrapper)
		throw std::invalid_argument("The argument is not userdata nor lightuserdata");
	if (wrapper->hash != XXH64(&wrapper->ptr, sizeof(wrapper->ptr), WRAPPER_SEED))
		throw std::invalid_argument("Invalid class object");
	value = (::CStickTestDlg *)wrapper->ptr;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6181)
/// <summary>
/// Pushes ::X value on Lua stack.
/// </summary>
template<>
void Sticklib::push_lvalue<::X*>(lua_State * L, ::X * const & value, bool own)
{
	//                   Premise.
	//       stack
	//    +---------+
	//  -1|   v1    |
	//    |---------|
	//    :         :
	//

	//       stack
	//    |---------|            +------------------+
	//  -1|userdata |----------->| allocated memory |
	//    |---------|            +------------------+
	//  -2|   v1    |
	//    |---------|            |------------------|
	//    :         :          sizeof(StickInstanceWrapper)
	//
	auto wrapper = (StickInstanceWrapper *)lua_newuserdata(L, sizeof(StickInstanceWrapper));
	wrapper->hash = XXH64(&value, sizeof(value), WRAPPER_SEED);
	wrapper->own = own;
	wrapper->ptr = value;

	//       stack
	//    |---------|
	//  -1|metatable|--------------------------+   +----------------------------------------+
	//    |---------|                          |   |                       registry         |
	//  -2|userdata |---+                      V   V                    +-------+-------+   |
	//    |---------|   |              +----------+--------+            | Key   | Value |   |
	//    |   v1    |   |              |   Key    | Value  |            |-------|-------|   |
	//    |---------|   |              |----------|--------|            |regName| table |---+
	//    :         :   |              |  "__gc"  |c++func1<---+        +---A---+-------+
	//                  |              +----------|--------+   |        :   |   :       :
	//                  |              | "xxxxx"  |c++func2|   |            |
	//                  |              +----------|--------+   |       metatable_name
	//                  |              :          :        :   |
	//                  |                                      |
	//                  |    +------------------+              |
	//                  +--->| allocated memory |        c++ Destructor
	//                       +------------------+
	//
	luaL_getmetatable(L, "lm__X__");

	//                             metatable
	//       stack              +--------------+   +----------------------------------------+
	//    |---------|           |              |   |                       registry         |
	//  -1|userdata |---+       |              V   V                    +-------+-------+   |
	//    |---------|   |       |      +----------+--------+            | Key   | Value |   |
	//    |   v1    |   |       |      |   Key    | Value  |            |-------|-------|   |
	//    |---------|   |       |      |----------|--------|            |regName| table |---+
	//    :         :   |       |      |  "__gc"  |c++func1<---+        +---A---+-------+
	//                  |       |      +----------|--------+   |        :   |   :       :
	//                  |       |      | "xxxxx"  |c++func2|   |            |
	//                  |       |      +----------|--------+   |       metatable_name
	//                  |       |      :          :        :   |
	//                  |       |                              |
	//                  |    +------------------+              |
	//                  +--->| allocated memory |        c++ Destructor
	//                       +------------------+
	//
	::lua_setmetatable(L, -2);
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6181)
/// <summary>
/// Pushes ::X::A value on Lua stack.
/// </summary>
template<>
void Sticklib::push_lvalue<::X::A*>(lua_State * L, ::X::A * const & value, bool own)
{
	//                   Premise.
	//       stack
	//    +---------+
	//  -1|   v1    |
	//    |---------|
	//    :         :
	//

	//       stack
	//    |---------|            +------------------+
	//  -1|userdata |----------->| allocated memory |
	//    |---------|            +------------------+
	//  -2|   v1    |
	//    |---------|            |------------------|
	//    :         :          sizeof(StickInstanceWrapper)
	//
	auto wrapper = (StickInstanceWrapper *)lua_newuserdata(L, sizeof(StickInstanceWrapper));
	wrapper->hash = XXH64(&value, sizeof(value), WRAPPER_SEED);
	wrapper->own = own;
	wrapper->ptr = value;

	//       stack
	//    |---------|
	//  -1|metatable|--------------------------+   +----------------------------------------+
	//    |---------|                          |   |                       registry         |
	//  -2|userdata |---+                      V   V                    +-------+-------+   |
	//    |---------|   |              +----------+--------+            | Key   | Value |   |
	//    |   v1    |   |              |   Key    | Value  |            |-------|-------|   |
	//    |---------|   |              |----------|--------|            |regName| table |---+
	//    :         :   |              |  "__gc"  |c++func1<---+        +---A---+-------+
	//                  |              +----------|--------+   |        :   |   :       :
	//                  |              | "xxxxx"  |c++func2|   |            |
	//                  |              +----------|--------+   |       metatable_name
	//                  |              :          :        :   |
	//                  |                                      |
	//                  |    +------------------+              |
	//                  +--->| allocated memory |        c++ Destructor
	//                       +------------------+
	//
	luaL_getmetatable(L, "lm__X__A__");

	//                             metatable
	//       stack              +--------------+   +----------------------------------------+
	//    |---------|           |              |   |                       registry         |
	//  -1|userdata |---+       |              V   V                    +-------+-------+   |
	//    |---------|   |       |      +----------+--------+            | Key   | Value |   |
	//    |   v1    |   |       |      |   Key    | Value  |            |-------|-------|   |
	//    |---------|   |       |      |----------|--------|            |regName| table |---+
	//    :         :   |       |      |  "__gc"  |c++func1<---+        +---A---+-------+
	//                  |       |      +----------|--------+   |        :   |   :       :
	//                  |       |      | "xxxxx"  |c++func2|   |            |
	//                  |       |      +----------|--------+   |       metatable_name
	//                  |       |      :          :        :   |
	//                  |       |                              |
	//                  |    +------------------+              |
	//                  +--->| allocated memory |        c++ Destructor
	//                       +------------------+
	//
	::lua_setmetatable(L, -2);
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6181)
/// <summary>
/// Pushes ::X::B value on Lua stack.
/// </summary>
template<>
void Sticklib::push_lvalue<::X::B*>(lua_State * L, ::X::B * const & value, bool own)
{
	//                   Premise.
	//       stack
	//    +---------+
	//  -1|   v1    |
	//    |---------|
	//    :         :
	//

	//       stack
	//    |---------|            +------------------+
	//  -1|userdata |----------->| allocated memory |
	//    |---------|            +------------------+
	//  -2|   v1    |
	//    |---------|            |------------------|
	//    :         :          sizeof(StickInstanceWrapper)
	//
	auto wrapper = (StickInstanceWrapper *)lua_newuserdata(L, sizeof(StickInstanceWrapper));
	wrapper->hash = XXH64(&value, sizeof(value), WRAPPER_SEED);
	wrapper->own = own;
	wrapper->ptr = value;

	//       stack
	//    |---------|
	//  -1|metatable|--------------------------+   +----------------------------------------+
	//    |---------|                          |   |                       registry         |
	//  -2|userdata |---+                      V   V                    +-------+-------+   |
	//    |---------|   |              +----------+--------+            | Key   | Value |   |
	//    |   v1    |   |              |   Key    | Value  |            |-------|-------|   |
	//    |---------|   |              |----------|--------|            |regName| table |---+
	//    :         :   |              |  "__gc"  |c++func1<---+        +---A---+-------+
	//                  |              +----------|--------+   |        :   |   :       :
	//                  |              | "xxxxx"  |c++func2|   |            |
	//                  |              +----------|--------+   |       metatable_name
	//                  |              :          :        :   |
	//                  |                                      |
	//                  |    +------------------+              |
	//                  +--->| allocated memory |        c++ Destructor
	//                       +------------------+
	//
	luaL_getmetatable(L, "lm__X__B__");

	//                             metatable
	//       stack              +--------------+   +----------------------------------------+
	//    |---------|           |              |   |                       registry         |
	//  -1|userdata |---+       |              V   V                    +-------+-------+   |
	//    |---------|   |       |      +----------+--------+            | Key   | Value |   |
	//    |   v1    |   |       |      |   Key    | Value  |            |-------|-------|   |
	//    |---------|   |       |      |----------|--------|            |regName| table |---+
	//    :         :   |       |      |  "__gc"  |c++func1<---+        +---A---+-------+
	//                  |       |      +----------|--------+   |        :   |   :       :
	//                  |       |      | "xxxxx"  |c++func2|   |            |
	//                  |       |      +----------|--------+   |       metatable_name
	//                  |       |      :          :        :   |
	//                  |       |                              |
	//                  |    +------------------+              |
	//                  +--->| allocated memory |        c++ Destructor
	//                       +------------------+
	//
	::lua_setmetatable(L, -2);
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6181)
/// <summary>
/// Pushes ::NM1::NM1_NM2 value on Lua stack.
/// </summary>
template<>
void Sticklib::push_lvalue<::NM1::NM1_NM2*>(lua_State * L, ::NM1::NM1_NM2 * const & value, bool own)
{
	//                   Premise.
	//       stack
	//    +---------+
	//  -1|   v1    |
	//    |---------|
	//    :         :
	//

	//       stack
	//    |---------|            +------------------+
	//  -1|userdata |----------->| allocated memory |
	//    |---------|            +------------------+
	//  -2|   v1    |
	//    |---------|            |------------------|
	//    :         :          sizeof(StickInstanceWrapper)
	//
	auto wrapper = (StickInstanceWrapper *)lua_newuserdata(L, sizeof(StickInstanceWrapper));
	wrapper->hash = XXH64(&value, sizeof(value), WRAPPER_SEED);
	wrapper->own = own;
	wrapper->ptr = value;

	//       stack
	//    |---------|
	//  -1|metatable|--------------------------+   +----------------------------------------+
	//    |---------|                          |   |                       registry         |
	//  -2|userdata |---+                      V   V                    +-------+-------+   |
	//    |---------|   |              +----------+--------+            | Key   | Value |   |
	//    |   v1    |   |              |   Key    | Value  |            |-------|-------|   |
	//    |---------|   |              |----------|--------|            |regName| table |---+
	//    :         :   |              |  "__gc"  |c++func1<---+        +---A---+-------+
	//                  |              +----------|--------+   |        :   |   :       :
	//                  |              | "xxxxx"  |c++func2|   |            |
	//                  |              +----------|--------+   |       metatable_name
	//                  |              :          :        :   |
	//                  |                                      |
	//                  |    +------------------+              |
	//                  +--->| allocated memory |        c++ Destructor
	//                       +------------------+
	//
	luaL_getmetatable(L, "lm__NM1__NM1_NM2__");

	//                             metatable
	//       stack              +--------------+   +----------------------------------------+
	//    |---------|           |              |   |                       registry         |
	//  -1|userdata |---+       |              V   V                    +-------+-------+   |
	//    |---------|   |       |      +----------+--------+            | Key   | Value |   |
	//    |   v1    |   |       |      |   Key    | Value  |            |-------|-------|   |
	//    |---------|   |       |      |----------|--------|            |regName| table |---+
	//    :         :   |       |      |  "__gc"  |c++func1<---+        +---A---+-------+
	//                  |       |      +----------|--------+   |        :   |   :       :
	//                  |       |      | "xxxxx"  |c++func2|   |            |
	//                  |       |      +----------|--------+   |       metatable_name
	//                  |       |      :          :        :   |
	//                  |       |                              |
	//                  |    +------------------+              |
	//                  +--->| allocated memory |        c++ Destructor
	//                       +------------------+
	//
	::lua_setmetatable(L, -2);
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6181)
/// <summary>
/// Pushes ::NM1::NM1_NM3 value on Lua stack.
/// </summary>
template<>
void Sticklib::push_lvalue<::NM1::NM1_NM3*>(lua_State * L, ::NM1::NM1_NM3 * const & value, bool own)
{
	//                   Premise.
	//       stack
	//    +---------+
	//  -1|   v1    |
	//    |---------|
	//    :         :
	//

	//       stack
	//    |---------|            +------------------+
	//  -1|userdata |----------->| allocated memory |
	//    |---------|            +------------------+
	//  -2|   v1    |
	//    |---------|            |------------------|
	//    :         :          sizeof(StickInstanceWrapper)
	//
	auto wrapper = (StickInstanceWrapper *)lua_newuserdata(L, sizeof(StickInstanceWrapper));
	wrapper->hash = XXH64(&value, sizeof(value), WRAPPER_SEED);
	wrapper->own = own;
	wrapper->ptr = value;

	//       stack
	//    |---------|
	//  -1|metatable|--------------------------+   +----------------------------------------+
	//    |---------|                          |   |                       registry         |
	//  -2|userdata |---+                      V   V                    +-------+-------+   |
	//    |---------|   |              +----------+--------+            | Key   | Value |   |
	//    |   v1    |   |              |   Key    | Value  |            |-------|-------|   |
	//    |---------|   |              |----------|--------|            |regName| table |---+
	//    :         :   |              |  "__gc"  |c++func1<---+        +---A---+-------+
	//                  |              +----------|--------+   |        :   |   :       :
	//                  |              | "xxxxx"  |c++func2|   |            |
	//                  |              +----------|--------+   |       metatable_name
	//                  |              :          :        :   |
	//                  |                                      |
	//                  |    +------------------+              |
	//                  +--->| allocated memory |        c++ Destructor
	//                       +------------------+
	//
	luaL_getmetatable(L, "lm__NM1__NM1_NM3__");

	//                             metatable
	//       stack              +--------------+   +----------------------------------------+
	//    |---------|           |              |   |                       registry         |
	//  -1|userdata |---+       |              V   V                    +-------+-------+   |
	//    |---------|   |       |      +----------+--------+            | Key   | Value |   |
	//    |   v1    |   |       |      |   Key    | Value  |            |-------|-------|   |
	//    |---------|   |       |      |----------|--------|            |regName| table |---+
	//    :         :   |       |      |  "__gc"  |c++func1<---+        +---A---+-------+
	//                  |       |      +----------|--------+   |        :   |   :       :
	//                  |       |      | "xxxxx"  |c++func2|   |            |
	//                  |       |      +----------|--------+   |       metatable_name
	//                  |       |      :          :        :   |
	//                  |       |                              |
	//                  |    +------------------+              |
	//                  +--->| allocated memory |        c++ Destructor
	//                       +------------------+
	//
	::lua_setmetatable(L, -2);
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6181)
/// <summary>
/// Pushes ::C value on Lua stack.
/// </summary>
template<>
void Sticklib::push_lvalue<::C*>(lua_State * L, ::C * const & value, bool own)
{
	//                   Premise.
	//       stack
	//    +---------+
	//  -1|   v1    |
	//    |---------|
	//    :         :
	//

	//       stack
	//    |---------|            +------------------+
	//  -1|userdata |----------->| allocated memory |
	//    |---------|            +------------------+
	//  -2|   v1    |
	//    |---------|            |------------------|
	//    :         :          sizeof(StickInstanceWrapper)
	//
	auto wrapper = (StickInstanceWrapper *)lua_newuserdata(L, sizeof(StickInstanceWrapper));
	wrapper->hash = XXH64(&value, sizeof(value), WRAPPER_SEED);
	wrapper->own = own;
	wrapper->ptr = value;

	//       stack
	//    |---------|
	//  -1|metatable|--------------------------+   +----------------------------------------+
	//    |---------|                          |   |                       registry         |
	//  -2|userdata |---+                      V   V                    +-------+-------+   |
	//    |---------|   |              +----------+--------+            | Key   | Value |   |
	//    |   v1    |   |              |   Key    | Value  |            |-------|-------|   |
	//    |---------|   |              |----------|--------|            |regName| table |---+
	//    :         :   |              |  "__gc"  |c++func1<---+        +---A---+-------+
	//                  |              +----------|--------+   |        :   |   :       :
	//                  |              | "xxxxx"  |c++func2|   |            |
	//                  |              +----------|--------+   |       metatable_name
	//                  |              :          :        :   |
	//                  |                                      |
	//                  |    +------------------+              |
	//                  +--->| allocated memory |        c++ Destructor
	//                       +------------------+
	//
	luaL_getmetatable(L, "lm__C__");

	//                             metatable
	//       stack              +--------------+   +----------------------------------------+
	//    |---------|           |              |   |                       registry         |
	//  -1|userdata |---+       |              V   V                    +-------+-------+   |
	//    |---------|   |       |      +----------+--------+            | Key   | Value |   |
	//    |   v1    |   |       |      |   Key    | Value  |            |-------|-------|   |
	//    |---------|   |       |      |----------|--------|            |regName| table |---+
	//    :         :   |       |      |  "__gc"  |c++func1<---+        +---A---+-------+
	//                  |       |      +----------|--------+   |        :   |   :       :
	//                  |       |      | "xxxxx"  |c++func2|   |            |
	//                  |       |      +----------|--------+   |       metatable_name
	//                  |       |      :          :        :   |
	//                  |       |                              |
	//                  |    +------------------+              |
	//                  +--->| allocated memory |        c++ Destructor
	//                       +------------------+
	//
	::lua_setmetatable(L, -2);
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6181)
/// <summary>
/// Pushes ::CStickTestDlg value on Lua stack.
/// </summary>
template<>
void Sticklib::push_lvalue<::CStickTestDlg*>(lua_State * L, ::CStickTestDlg * const & value, bool own)
{
	//                   Premise.
	//       stack
	//    +---------+
	//  -1|   v1    |
	//    |---------|
	//    :         :
	//

	//       stack
	//    |---------|            +------------------+
	//  -1|userdata |----------->| allocated memory |
	//    |---------|            +------------------+
	//  -2|   v1    |
	//    |---------|            |------------------|
	//    :         :          sizeof(StickInstanceWrapper)
	//
	auto wrapper = (StickInstanceWrapper *)lua_newuserdata(L, sizeof(StickInstanceWrapper));
	wrapper->hash = XXH64(&value, sizeof(value), WRAPPER_SEED);
	wrapper->own = own;
	wrapper->ptr = value;

	//       stack
	//    |---------|
	//  -1|metatable|--------------------------+   +----------------------------------------+
	//    |---------|                          |   |                       registry         |
	//  -2|userdata |---+                      V   V                    +-------+-------+   |
	//    |---------|   |              +----------+--------+            | Key   | Value |   |
	//    |   v1    |   |              |   Key    | Value  |            |-------|-------|   |
	//    |---------|   |              |----------|--------|            |regName| table |---+
	//    :         :   |              |  "__gc"  |c++func1<---+        +---A---+-------+
	//                  |              +----------|--------+   |        :   |   :       :
	//                  |              | "xxxxx"  |c++func2|   |            |
	//                  |              +----------|--------+   |       metatable_name
	//                  |              :          :        :   |
	//                  |                                      |
	//                  |    +------------------+              |
	//                  +--->| allocated memory |        c++ Destructor
	//                       +------------------+
	//
	luaL_getmetatable(L, "lm__CStickTestDlg__");

	//                             metatable
	//       stack              +--------------+   +----------------------------------------+
	//    |---------|           |              |   |                       registry         |
	//  -1|userdata |---+       |              V   V                    +-------+-------+   |
	//    |---------|   |       |      +----------+--------+            | Key   | Value |   |
	//    |   v1    |   |       |      |   Key    | Value  |            |-------|-------|   |
	//    |---------|   |       |      |----------|--------|            |regName| table |---+
	//    :         :   |       |      |  "__gc"  |c++func1<---+        +---A---+-------+
	//                  |       |      +----------|--------+   |        :   |   :       :
	//                  |       |      | "xxxxx"  |c++func2|   |            |
	//                  |       |      +----------|--------+   |       metatable_name
	//                  |       |      :          :        :   |
	//                  |       |                              |
	//                  |    +------------------+              |
	//                  +--->| allocated memory |        c++ Destructor
	//                       +------------------+
	//
	::lua_setmetatable(L, -2);
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6279)
/// <summary>
/// ::X::~X()
/// </summary>
static int lm__X__Destructor(lua_State* L)
{
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Get the class object.
		auto wrapper = (StickInstanceWrapper*)Sticklib::test_classobject(L, 1, "lm__X__");
		if (!wrapper)
			throw std::invalid_argument("The argument is not userdata nor lightuserdata");
		if (wrapper->hash != XXH64(&wrapper->ptr, sizeof(wrapper->ptr), WRAPPER_SEED))
			throw std::invalid_argument("Invalid class object");
		if (wrapper->own && wrapper->ptr != nullptr)
		{
			delete (::X*)wrapper->ptr;
			wrapper->ptr = nullptr;
		}
	}
	catch (std::exception & e)
	{
		luaL_error(L, (std::string("C function error:::X::~X:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::~X");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6279)
/// <summary>
/// ::X::A::~A()
/// </summary>
static int lm__X__A__Destructor(lua_State* L)
{
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Get the class object.
		auto wrapper = (StickInstanceWrapper*)Sticklib::test_classobject(L, 1, "lm__X__A__");
		if (!wrapper)
			throw std::invalid_argument("The argument is not userdata nor lightuserdata");
		if (wrapper->hash != XXH64(&wrapper->ptr, sizeof(wrapper->ptr), WRAPPER_SEED))
			throw std::invalid_argument("Invalid class object");
		if (wrapper->own && wrapper->ptr != nullptr)
		{
			delete (::X::A*)wrapper->ptr;
			wrapper->ptr = nullptr;
		}
	}
	catch (std::exception & e)
	{
		luaL_error(L, (std::string("C function error:::X::A::~A:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::A::~A");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6279)
/// <summary>
/// ::X::B::~B()
/// </summary>
static int lm__X__B__Destructor(lua_State* L)
{
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Get the class object.
		auto wrapper = (StickInstanceWrapper*)Sticklib::test_classobject(L, 1, "lm__X__B__");
		if (!wrapper)
			throw std::invalid_argument("The argument is not userdata nor lightuserdata");
		if (wrapper->hash != XXH64(&wrapper->ptr, sizeof(wrapper->ptr), WRAPPER_SEED))
			throw std::invalid_argument("Invalid class object");
		if (wrapper->own && wrapper->ptr != nullptr)
		{
			delete (::X::B*)wrapper->ptr;
			wrapper->ptr = nullptr;
		}
	}
	catch (std::exception & e)
	{
		luaL_error(L, (std::string("C function error:::X::B::~B:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::B::~B");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6279)
/// <summary>
/// ::NM1::NM1_NM2::~NM1_NM2()
/// </summary>
static int lm__NM1__NM1_NM2__Destructor(lua_State* L)
{
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Get the class object.
		auto wrapper = (StickInstanceWrapper*)Sticklib::test_classobject(L, 1, "lm__NM1__NM1_NM2__");
		if (!wrapper)
			throw std::invalid_argument("The argument is not userdata nor lightuserdata");
		if (wrapper->hash != XXH64(&wrapper->ptr, sizeof(wrapper->ptr), WRAPPER_SEED))
			throw std::invalid_argument("Invalid class object");
		if (wrapper->own && wrapper->ptr != nullptr)
		{
			delete (::NM1::NM1_NM2*)wrapper->ptr;
			wrapper->ptr = nullptr;
		}
	}
	catch (std::exception & e)
	{
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM2::~NM1_NM2:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM2::~NM1_NM2");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6279)
/// <summary>
/// ::NM1::NM1_NM3::~NM1_NM3()
/// </summary>
static int lm__NM1__NM1_NM3__Destructor(lua_State* L)
{
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Get the class object.
		auto wrapper = (StickInstanceWrapper*)Sticklib::test_classobject(L, 1, "lm__NM1__NM1_NM3__");
		if (!wrapper)
			throw std::invalid_argument("The argument is not userdata nor lightuserdata");
		if (wrapper->hash != XXH64(&wrapper->ptr, sizeof(wrapper->ptr), WRAPPER_SEED))
			throw std::invalid_argument("Invalid class object");
		if (wrapper->own && wrapper->ptr != nullptr)
		{
			delete (::NM1::NM1_NM3*)wrapper->ptr;
			wrapper->ptr = nullptr;
		}
	}
	catch (std::exception & e)
	{
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM3::~NM1_NM3:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM3::~NM1_NM3");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6279)
/// <summary>
/// ::C::~C()
/// </summary>
static int lm__C__Destructor(lua_State* L)
{
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Get the class object.
		auto wrapper = (StickInstanceWrapper*)Sticklib::test_classobject(L, 1, "lm__C__");
		if (!wrapper)
			throw std::invalid_argument("The argument is not userdata nor lightuserdata");
		if (wrapper->hash != XXH64(&wrapper->ptr, sizeof(wrapper->ptr), WRAPPER_SEED))
			throw std::invalid_argument("Invalid class object");
		if (wrapper->own && wrapper->ptr != nullptr)
		{
			delete (::C*)wrapper->ptr;
			wrapper->ptr = nullptr;
		}
	}
	catch (std::exception & e)
	{
		luaL_error(L, (std::string("C function error:::C::~C:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::C::~C");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6279)
/// <summary>
/// ::CStickTestDlg::~CStickTestDlg()
/// </summary>
static int lm__CStickTestDlg__Destructor(lua_State* L)
{
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Get the class object.
		auto wrapper = (StickInstanceWrapper*)Sticklib::test_classobject(L, 1, "lm__CStickTestDlg__");
		if (!wrapper)
			throw std::invalid_argument("The argument is not userdata nor lightuserdata");
		if (wrapper->hash != XXH64(&wrapper->ptr, sizeof(wrapper->ptr), WRAPPER_SEED))
			throw std::invalid_argument("Invalid class object");
		if (wrapper->own && wrapper->ptr != nullptr)
		{
			delete (::CStickTestDlg*)wrapper->ptr;
			wrapper->ptr = nullptr;
		}
	}
	catch (std::exception & e)
	{
		luaL_error(L, (std::string("C function error:::CStickTestDlg::~CStickTestDlg:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::CStickTestDlg::~CStickTestDlg");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::MyArrayFunc0(std::vector<std::string>& v1)
/// </summary>
static int slm__MyArrayFunc0__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		std::vector<std::string> v1;
		Sticklib::check_array<std::string>(v1, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4519)
		// Call the c++ function.
		::MyArrayFunc0((std::vector<std::string>&)v1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4740)
		Sticklib::push_array<std::string>(L, v1, false);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::MyArrayFunc0:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::MyArrayFunc0");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::MyArrayFunc1(std::vector<int>& v1)
/// </summary>
static int slm__MyArrayFunc1__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		std::vector<__int64> _argin_1_1;
		Sticklib::check_array<__int64>(_argin_1_1, L, 1);
		std::vector<int> v1;
		Sticklib::vectorT_to_vectorU<int,__int64>(v1, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4519)
		// Call the c++ function.
		::MyArrayFunc1((std::vector<int>&)v1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4669)
		std::vector<__int64> _argout_1_1;
		Sticklib::vectorT_to_vectorU<__int64,int>(_argout_1_1, v1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4740)
		Sticklib::push_array<__int64>(L, _argout_1_1, false);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::MyArrayFunc1:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::MyArrayFunc1");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::MyArrayFunc2(std::vector<std::wstring>& v1)
/// </summary>
static int slm__MyArrayFunc2__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		std::vector<std::string> _argin_1_1;
		Sticklib::check_array<std::string>(_argin_1_1, L, 1);
		std::vector<std::wstring> v1;
		Sticklib::vectorT_to_vectorU<std::wstring,std::string>(v1, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4519)
		// Call the c++ function.
		::MyArrayFunc2((std::vector<std::wstring>&)v1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4669)
		std::vector<std::string> _argout_1_1;
		Sticklib::vectorT_to_vectorU<std::string,std::wstring>(_argout_1_1, v1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4740)
		Sticklib::push_array<std::string>(L, _argout_1_1, false);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::MyArrayFunc2:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::MyArrayFunc2");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::MyFunc1(std::wstring& wstr1, wchar_t* wcp2)
/// </summary>
static int slm__MyFunc1__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		std::string _argin_1_1;
		Sticklib::check_lvalue<std::string>(_argin_1_1, L, 1);
		std::wstring wstr1;
		Sticklib::T_to_U<std::wstring, std::string>(wstr1, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		std::string _argin_2_1;
		Sticklib::check_lvalue<std::string>(_argin_2_1, L, 2);
		std::wstring _argin_2_2;
		Sticklib::T_to_U<std::wstring, std::string>(_argin_2_2, _argin_2_1);
		wchar_t* wcp2;
		Sticklib::T_to_U<wchar_t*,std::wstring>(wcp2, _argin_2_2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4533)
		// Call the c++ function.
		auto __lstickvar_ret = (std::wstring)::MyFunc1((std::wstring&)wstr1, (const wchar_t*)wcp2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4669)
		std::string _argout_0_1;
		Sticklib::Sticklib::T_to_U<std::string, std::wstring>(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4740)
		Sticklib::push_lvalue<std::string>(L, _argout_0_1, false);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4669)
		std::string _argout_1_1;
		Sticklib::Sticklib::T_to_U<std::string, std::wstring>(_argout_1_1, wstr1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4740)
		Sticklib::push_lvalue<std::string>(L, _argout_1_1, false);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::MyFunc1:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::MyFunc1");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::MyFunc2(double& v1, __int64 v2)
/// </summary>
static int slm__MyFunc2__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		double v1;
		Sticklib::check_lvalue<double>(v1, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		__int64 v2;
		Sticklib::check_lvalue<__int64>(v2, L, 2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4533)
		// Call the c++ function.
		auto __lstickvar_ret = (int)::MyFunc2((double&)v1, (__int64)v2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4669)
		__int64 _argout_0_1;
		Sticklib::T_to_U<__int64,int>(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4740)
		Sticklib::push_lvalue<__int64>(L, _argout_0_1, false);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4740)
		Sticklib::push_lvalue<double>(L, v1, false);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::MyFunc2:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::MyFunc2");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::RawFunc()
/// </summary>
static int slm__RawFunc__0(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4473)
		const auto _index_top = lua_gettop(L);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4519)
		// Call the c++ function.
		::RawFunc(L);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4751)
		return (int)(lua_gettop(L) - _index_top);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::RawFunc:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::RawFunc");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::ShowMessage(wchar_t* text)
/// </summary>
static int slm__ShowMessage__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		std::string _argin_1_1;
		Sticklib::check_lvalue<std::string>(_argin_1_1, L, 1);
		std::wstring _argin_1_2;
		Sticklib::T_to_U<std::wstring, std::string>(_argin_1_2, _argin_1_1);
		wchar_t* text;
		Sticklib::T_to_U<wchar_t*,std::wstring>(text, _argin_1_2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4519)
		// Call the c++ function.
		::ShowMessage((const wchar_t*)text);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::ShowMessage:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::ShowMessage");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::ToStickTestDlg(void* data)
/// </summary>
static int slm__ToStickTestDlg__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		void* data;
		Sticklib::check_lvalue<void*>(data, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4533)
		// Call the c++ function.
		auto __lstickvar_ret = (::CStickTestDlg*)::ToStickTestDlg((void*)data);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4740)
		Sticklib::push_lvalue<::CStickTestDlg*>(L, __lstickvar_ret, false);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::ToStickTestDlg:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::ToStickTestDlg");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::X::X()
/// </summary>
static int clm__X__New__0(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 0)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4543)
		// Create the class object and give back it to lua.
		auto obj = new ::X();
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4584)
		Sticklib::push_lvalue<::X*>(L, obj, true);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::X::X:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::X");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::X::A::FuncX(::X::Enum1& x)
/// </summary>
static int mlm__X__A__FuncX__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4338)
		// Get the class object.
		::X::A * __lstickobj;
		Sticklib::check_lvalue<::X::A*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		__int64 _argin_1_1;
		Sticklib::check_lvalue<__int64>(_argin_1_1, L, 2);
		::X::Enum1 x;
		Sticklib::T_to_U<::X::Enum1, __int64>(x, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4489)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		__lstickobj->FuncX((enum class ::X::Enum1&)x);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4669)
		__int64 _argout_1_1;
		Sticklib::T_to_U<__int64, ::X::Enum1>(_argout_1_1, x);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4740)
		Sticklib::push_lvalue<__int64>(L, _argout_1_1, false);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::X::A::FuncX:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::A::FuncX");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::X::A::Get()
/// </summary>
static int mlm__X__A__Get__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4338)
		// Get the class object.
		::X::A * __lstickobj;
		Sticklib::check_lvalue<::X::A*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4506)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		auto __lstickvar_ret = (int)__lstickobj->Get();
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4669)
		__int64 _argout_0_1;
		Sticklib::T_to_U<__int64,int>(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4740)
		Sticklib::push_lvalue<__int64>(L, _argout_0_1, false);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::X::A::Get:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::A::Get");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::X::A::GetSet(int* a)
/// </summary>
static int mlm__X__A__GetSet__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4338)
		// Get the class object.
		::X::A * __lstickobj;
		Sticklib::check_lvalue<::X::A*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4449)
		int _argin_1_1;
		int* a = &_argin_1_1;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4489)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		__lstickobj->GetSet((int*)a);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4660)
		int& _argout_1_1 = *a;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4669)
		__int64 _argout_1_2;
		Sticklib::T_to_U<__int64,int>(_argout_1_2, _argout_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4740)
		Sticklib::push_lvalue<__int64>(L, _argout_1_2, false);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::X::A::GetSet:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::A::GetSet");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::X::A::Set(int a)
/// </summary>
static int mlm__X__A__Set__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4338)
		// Get the class object.
		::X::A * __lstickobj;
		Sticklib::check_lvalue<::X::A*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		__int64 _argin_1_1;
		Sticklib::check_lvalue<__int64>(_argin_1_1, L, 2);
		int a;
		Sticklib::T_to_U<int,__int64>(a, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4489)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		__lstickobj->Set((int)a);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::X::A::Set:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::A::Set");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::X::A::Set(int a, int b)
/// </summary>
static int mlm__X__A__Set__3(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 3)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4338)
		// Get the class object.
		::X::A * __lstickobj;
		Sticklib::check_lvalue<::X::A*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		__int64 _argin_1_1;
		Sticklib::check_lvalue<__int64>(_argin_1_1, L, 2);
		int a;
		Sticklib::T_to_U<int,__int64>(a, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		__int64 _argin_2_1;
		Sticklib::check_lvalue<__int64>(_argin_2_1, L, 3);
		int b;
		Sticklib::T_to_U<int,__int64>(b, _argin_2_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4489)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		__lstickobj->Set((int)a, (int)b);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::X::A::Set:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::A::Set");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::X::A::New(int a)
/// </summary>
static int clm__X__A__New__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		__int64 _argin_1_1;
		Sticklib::check_lvalue<__int64>(_argin_1_1, L, 1);
		int a;
		Sticklib::T_to_U<int,__int64>(a, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4543)
		// Create the class object and give back it to lua.
		auto obj = new ::X::A((int)a);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4584)
		Sticklib::push_lvalue<::X::A*>(L, obj, true);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::X::A::New:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::A::New");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::X::B::Add1(::X::A*& a)
/// </summary>
static int mlm__X__B__Add1__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4338)
		// Get the class object.
		::X::B * __lstickobj;
		Sticklib::check_lvalue<::X::B*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4460)
		::X::A* a;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4506)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		auto __lstickvar_ret = (int)__lstickobj->Add1((::X::A*&)a);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4669)
		__int64 _argout_0_1;
		Sticklib::T_to_U<__int64,int>(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4740)
		Sticklib::push_lvalue<__int64>(L, _argout_0_1, false);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4740)
		Sticklib::push_lvalue<::X::A*>(L, a, false);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::X::B::Add1:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::B::Add1");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::X::B::Add2(::X::A* a)
/// </summary>
static int mlm__X__B__Add2__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4338)
		// Get the class object.
		::X::B * __lstickobj;
		Sticklib::check_lvalue<::X::B*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		::X::A* a;
		Sticklib::check_lvalue<::X::A*>(a, L, 2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4489)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		__lstickobj->Add2((class ::X::A*)a);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::X::B::Add2:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::B::Add2");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::X::B::CreateA(int a)
/// </summary>
static int slm__X__B__CreateA__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		__int64 _argin_1_1;
		Sticklib::check_lvalue<__int64>(_argin_1_1, L, 1);
		int a;
		Sticklib::T_to_U<int,__int64>(a, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4533)
		// Call the c++ function.
		auto __lstickvar_ret = (::X::A*)::X::B::CreateA((int)a);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4740)
		Sticklib::push_lvalue<::X::A*>(L, __lstickvar_ret, false);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::X::B::CreateA:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::B::CreateA");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::X::B::DeleteA(::X::A* a)
/// </summary>
static int slm__X__B__DeleteA__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		::X::A* a;
		Sticklib::check_lvalue<::X::A*>(a, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4519)
		// Call the c++ function.
		::X::B::DeleteA((::X::A*)a);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::X::B::DeleteA:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::B::DeleteA");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::X::B::B()
/// </summary>
static int clm__X__B__New__0(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 0)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4543)
		// Create the class object and give back it to lua.
		auto obj = new ::X::B();
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4584)
		Sticklib::push_lvalue<::X::B*>(L, obj, true);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::X::B::B:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::X::B::B");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::NM1::MyFunc2(double& v1, __int64 v2)
/// </summary>
static int slm__NM1__MyFunc2__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		double v1;
		Sticklib::check_lvalue<double>(v1, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		__int64 v2;
		Sticklib::check_lvalue<__int64>(v2, L, 2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4533)
		// Call the c++ function.
		auto __lstickvar_ret = (int)::NM1::MyFunc2((double&)v1, (__int64)v2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4669)
		__int64 _argout_0_1;
		Sticklib::T_to_U<__int64,int>(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4740)
		Sticklib::push_lvalue<__int64>(L, _argout_0_1, false);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4740)
		Sticklib::push_lvalue<double>(L, v1, false);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::NM1::MyFunc2:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::MyFunc2");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::NM1::NM1_NM1::MyFunc0(void* array)
/// </summary>
static int slm__NM1__NM1_NM1__MyFunc0__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		void* array;
		Sticklib::check_lvalue<void*>(array, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4519)
		// Call the c++ function.
		::NM1::NM1_NM1::MyFunc0((const int*)array);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM1::MyFunc0:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM1::MyFunc0");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::NM1::NM1_NM1::MyFunc1(std::wstring& wstr1, wchar_t* wcp2)
/// </summary>
static int slm__NM1__NM1_NM1__MyFunc1__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		std::string _argin_1_1;
		Sticklib::check_lvalue<std::string>(_argin_1_1, L, 1);
		std::wstring wstr1;
		Sticklib::T_to_U<std::wstring, std::string>(wstr1, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		std::string _argin_2_1;
		Sticklib::check_lvalue<std::string>(_argin_2_1, L, 2);
		std::wstring _argin_2_2;
		Sticklib::T_to_U<std::wstring, std::string>(_argin_2_2, _argin_2_1);
		wchar_t* wcp2;
		Sticklib::T_to_U<wchar_t*,std::wstring>(wcp2, _argin_2_2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4533)
		// Call the c++ function.
		auto __lstickvar_ret = (std::wstring)::NM1::NM1_NM1::MyFunc1((std::wstring&)wstr1, (const wchar_t*)wcp2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4669)
		std::string _argout_0_1;
		Sticklib::Sticklib::T_to_U<std::string, std::wstring>(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4740)
		Sticklib::push_lvalue<std::string>(L, _argout_0_1, false);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4669)
		std::string _argout_1_1;
		Sticklib::Sticklib::T_to_U<std::string, std::wstring>(_argout_1_1, wstr1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4740)
		Sticklib::push_lvalue<std::string>(L, _argout_1_1, false);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM1::MyFunc1:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM1::MyFunc1");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::NM1::NM1_NM1::MyFunc2(std::string& v1)
/// </summary>
static int slm__NM1__NM1_NM1__MyFunc2x__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		std::string v1;
		Sticklib::check_lvalue<std::string>(v1, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4533)
		// Call the c++ function.
		auto __lstickvar_ret = (int)::NM1::NM1_NM1::MyFunc2((std::string&)v1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4669)
		__int64 _argout_0_1;
		Sticklib::T_to_U<__int64,int>(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4740)
		Sticklib::push_lvalue<__int64>(L, _argout_0_1, false);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4740)
		Sticklib::push_lvalue<std::string>(L, v1, false);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM1::MyFunc2:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM1::MyFunc2");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::NM1::NM1_NM1::MyFunc2(double& v1)
/// </summary>
static int slm__NM1__NM1_NM1__MyFunc2y__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		double v1;
		Sticklib::check_lvalue<double>(v1, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4533)
		// Call the c++ function.
		auto __lstickvar_ret = (int)::NM1::NM1_NM1::MyFunc2((double&)v1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4669)
		__int64 _argout_0_1;
		Sticklib::T_to_U<__int64,int>(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4740)
		Sticklib::push_lvalue<__int64>(L, _argout_0_1, false);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4740)
		Sticklib::push_lvalue<double>(L, v1, false);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM1::MyFunc2:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM1::MyFunc2");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::NM1::NM1_NM1::MyFunc2(double& v1, __int64 v2)
/// </summary>
static int slm__NM1__NM1_NM1__MyFunc2y__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		double v1;
		Sticklib::check_lvalue<double>(v1, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		__int64 v2;
		Sticklib::check_lvalue<__int64>(v2, L, 2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4533)
		// Call the c++ function.
		auto __lstickvar_ret = (int)::NM1::NM1_NM1::MyFunc2((double&)v1, (__int64)v2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4669)
		__int64 _argout_0_1;
		Sticklib::T_to_U<__int64,int>(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4740)
		Sticklib::push_lvalue<__int64>(L, _argout_0_1, false);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4740)
		Sticklib::push_lvalue<double>(L, v1, false);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM1::MyFunc2:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM1::MyFunc2");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::NM1::NM1_NM2::MyFunc2(double& v1, __int64 v2)
/// </summary>
static int mlm__NM1__NM1_NM2__MyFunc2__3(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 3)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4338)
		// Get the class object.
		::NM1::NM1_NM2 * __lstickobj;
		Sticklib::check_lvalue<::NM1::NM1_NM2*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		double v1;
		Sticklib::check_lvalue<double>(v1, L, 2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		__int64 v2;
		Sticklib::check_lvalue<__int64>(v2, L, 3);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4506)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		auto __lstickvar_ret = (int)__lstickobj->MyFunc2((double&)v1, (__int64)v2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4669)
		__int64 _argout_0_1;
		Sticklib::T_to_U<__int64,int>(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4740)
		Sticklib::push_lvalue<__int64>(L, _argout_0_1, false);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4740)
		Sticklib::push_lvalue<double>(L, v1, false);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM2::MyFunc2:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM2::MyFunc2");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::NM1::NM1_NM2::New()
/// </summary>
static int clm__NM1__NM1_NM2__New__0(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 0)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4543)
		// Create the class object and give back it to lua.
		auto obj = new ::NM1::NM1_NM2();
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4584)
		Sticklib::push_lvalue<::NM1::NM1_NM2*>(L, obj, true);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM2::New:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM2::New");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::NM1::NM1_NM2::New(int& a)
/// </summary>
static int clm__NM1__NM1_NM2__New__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		__int64 _argin_1_1;
		Sticklib::check_lvalue<__int64>(_argin_1_1, L, 1);
		int a;
		Sticklib::T_to_U<int,__int64>(a, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4543)
		// Create the class object and give back it to lua.
		auto obj = new ::NM1::NM1_NM2((int&)a);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4584)
		Sticklib::push_lvalue<::NM1::NM1_NM2*>(L, obj, true);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4669)
		__int64 _argout_1_1;
		Sticklib::T_to_U<__int64,int>(_argout_1_1, a);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4740)
		Sticklib::push_lvalue<__int64>(L, _argout_1_1, false);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM2::New:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM2::New");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::NM1::NM1_NM3::MyFunc3(double& v1)
/// </summary>
static int mlm__NM1__NM1_NM3__MyFunc3__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4338)
		// Get the class object.
		::NM1::NM1_NM3 * __lstickobj;
		Sticklib::check_lvalue<::NM1::NM1_NM3*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		double v1;
		Sticklib::check_lvalue<double>(v1, L, 2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4506)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		auto __lstickvar_ret = (int)__lstickobj->MyFunc3((double&)v1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4669)
		__int64 _argout_0_1;
		Sticklib::T_to_U<__int64,int>(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4740)
		Sticklib::push_lvalue<__int64>(L, _argout_0_1, false);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4740)
		Sticklib::push_lvalue<double>(L, v1, false);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM3::MyFunc3:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM3::MyFunc3");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::NM1::NM1_NM3::MyFunc3(double& v1, __int64 v2)
/// </summary>
static int mlm__NM1__NM1_NM3__MyFunc3__3(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 3)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4338)
		// Get the class object.
		::NM1::NM1_NM3 * __lstickobj;
		Sticklib::check_lvalue<::NM1::NM1_NM3*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		double v1;
		Sticklib::check_lvalue<double>(v1, L, 2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		__int64 v2;
		Sticklib::check_lvalue<__int64>(v2, L, 3);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4506)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		auto __lstickvar_ret = (int)__lstickobj->MyFunc3((double&)v1, (__int64)v2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4669)
		__int64 _argout_0_1;
		Sticklib::T_to_U<__int64,int>(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4740)
		Sticklib::push_lvalue<__int64>(L, _argout_0_1, false);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4740)
		Sticklib::push_lvalue<double>(L, v1, false);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM3::MyFunc3:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM3::MyFunc3");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::NM1::NM1_NM3::NM1_NM3()
/// </summary>
static int clm__NM1__NM1_NM3__New__0(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 0)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4543)
		// Create the class object and give back it to lua.
		auto obj = new ::NM1::NM1_NM3();
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4584)
		Sticklib::push_lvalue<::NM1::NM1_NM3*>(L, obj, true);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::NM1::NM1_NM3::NM1_NM3:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM1::NM1_NM3::NM1_NM3");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::C::C()
/// </summary>
static int clm__C__New__0(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 0)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4543)
		// Create the class object and give back it to lua.
		auto obj = new ::C();
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4584)
		Sticklib::push_lvalue<::C*>(L, obj, true);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::C::C:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::C::C");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::NM2::MyFunc2(double& v1, __int64 v2)
/// </summary>
static int slm__NM2__MyFunc2__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		double v1;
		Sticklib::check_lvalue<double>(v1, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		__int64 v2;
		Sticklib::check_lvalue<__int64>(v2, L, 2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4533)
		// Call the c++ function.
		auto __lstickvar_ret = (int)::NM2::MyFunc2((double&)v1, (__int64)v2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4669)
		__int64 _argout_0_1;
		Sticklib::T_to_U<__int64,int>(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4740)
		Sticklib::push_lvalue<__int64>(L, _argout_0_1, false);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4740)
		Sticklib::push_lvalue<double>(L, v1, false);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::NM2::MyFunc2:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::NM2::MyFunc2");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::CStickTestDlg::DebugOutput(char* message)
/// </summary>
static int mlm__CStickTestDlg__DebugOutput__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4338)
		// Get the class object.
		::CStickTestDlg * __lstickobj;
		Sticklib::check_lvalue<::CStickTestDlg*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		std::string _argin_1_1;
		Sticklib::check_lvalue<std::string>(_argin_1_1, L, 2);
		char* message;
		Sticklib::T_to_U<char *, std::string>(message, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4489)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		__lstickobj->DebugOutput((const char*)message);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::CStickTestDlg::DebugOutput:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::CStickTestDlg::DebugOutput");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::CStickTestDlg::CStickTestDlg()
/// </summary>
static int clm__CStickTestDlg__New__0(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 0)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4543)
		// Create the class object and give back it to lua.
		auto obj = new ::CStickTestDlg();
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4584)
		Sticklib::push_lvalue<::CStickTestDlg*>(L, obj, true);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::CStickTestDlg::CStickTestDlg:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::CStickTestDlg::CStickTestDlg");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7519)
/// <summary>
/// X.A.Set(...)
/// Distribute the process to the polymorphic functions. X.A.Set(...)
/// </summary>
static int lm__X__A__Set(lua_State* L)
{
	switch (lua_gettop(L))
	{
	case 2:
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7532)
		return mlm__X__A__Set__2(L);
	case 3:
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7532)
		return mlm__X__A__Set__3(L);
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7542)
	default:
		luaL_error(L, "incorrect argument");
		return 0;
	}
}
// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7519)
/// <summary>
/// NM1.MMM1.MyFunc2y(...)
/// Distribute the process to the polymorphic functions. NM1.MMM1.MyFunc2y(...)
/// </summary>
static int lm__NM1__NM1_NM1__MyFunc2y(lua_State* L)
{
	switch (lua_gettop(L))
	{
	case 1:
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7532)
		return slm__NM1__NM1_NM1__MyFunc2y__1(L);
	case 2:
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7532)
		return slm__NM1__NM1_NM1__MyFunc2y__2(L);
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7542)
	default:
		luaL_error(L, "incorrect argument");
		return 0;
	}
}
// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7519)
/// <summary>
/// NM1.NM1_NM2.New(...)
/// Distribute the process to the polymorphic functions. NM1.NM1_NM2.New(...)
/// </summary>
static int lm__NM1__NM1_NM2__New(lua_State* L)
{
	switch (lua_gettop(L))
	{
	case 0:
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7532)
		return clm__NM1__NM1_NM2__New__0(L);
	case 1:
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7532)
		return clm__NM1__NM1_NM2__New__1(L);
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7542)
	default:
		luaL_error(L, "incorrect argument");
		return 0;
	}
}
// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7519)
/// <summary>
/// NM1.NM1_NM3.MyFunc3(...)
/// Distribute the process to the polymorphic functions. NM1.NM1_NM3.MyFunc3(...)
/// </summary>
static int lm__NM1__NM1_NM3__MyFunc3(lua_State* L)
{
	switch (lua_gettop(L))
	{
	case 2:
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7532)
		return mlm__NM1__NM1_NM3__MyFunc3__2(L);
	case 3:
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7532)
		return mlm__NM1__NM1_NM3__MyFunc3__3(L);
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7542)
	default:
		luaL_error(L, "incorrect argument");
		return 0;
	}
}
// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8997)
/// <summary>
/// STICK::ObjectToUserdata(obj)
/// </summary>
static int lm__STICK__ObjectToUserdata__1(lua_State* L)
{
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		auto wrapper = (StickInstanceWrapper *)lua_touserdata(L, 1);
		if (!wrapper)
			throw std::invalid_argument("The argument is not userdata nor lightuserdata");
		if (wrapper->hash != XXH64(&wrapper->ptr, sizeof(wrapper->ptr), WRAPPER_SEED))
			throw std::invalid_argument("Invalid class object");
		Sticklib::push_lvalue<void *>(L, wrapper->ptr, false);
	}
	catch (std::exception & e)
	{
		luaL_error(L, (std::string("C function error:STICK::ObjectToUserdata:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:STICK::ObjectToUserdata");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8997)
/// <summary>
/// STICK::IsNullObject(obj)
/// </summary>
static int lm__STICK__IsNullObject__1(lua_State* L)
{
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		auto wrapper = (StickInstanceWrapper *)lua_touserdata(L, 1);
		if (!wrapper)
			throw std::invalid_argument("The argument is not userdata nor lightuserdata");
		if (wrapper->hash != XXH64(&wrapper->ptr, sizeof(wrapper->ptr), WRAPPER_SEED))
			throw std::invalid_argument("Invalid class object");
		bool isNull = (wrapper->ptr == nullptr);
		Sticklib::push_lvalue<bool>(L, isNull, false);
	}
	catch (std::exception & e)
	{
		luaL_error(L, (std::string("C function error:STICK::IsNullObject:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:STICK::IsNullObject");
	}
	return 1;
}

/// <summary>
/// LuaStick initializing function.
/// luastick_init must be called to register the classes and its member functions.
/// </summary>
void luastick_init(lua_State* L)
{
	std::random_device seed_gen;
	std::mt19937 engine(seed_gen());
	// Validation id for StickInstanceWrapper.
	WRAPPER_SEED = ((unsigned __int64)engine() << 32) | (unsigned __int64)engine();

	// Register the default namespace '::STICK' and its static member functions.
	Sticklib::push_table(L, "");
	Sticklib::push_table(L, "STICK");
	{
		static struct luaL_Reg lm__STICK__Static[] =
		{
			{ "ObjectToUserdata", lm__STICK__ObjectToUserdata__1 },
			{ "IsNullObject", lm__STICK__IsNullObject__1 },
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__STICK__Static);
	}
	Sticklib::pop(L);
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7762)
	// Register the global functions.
	Sticklib::push_table(L, "");
	{
		static struct luaL_Reg lm__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7781)
			{ "MyArrayFunc0", slm__MyArrayFunc0__1 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7781)
			{ "MyArrayFunc1", slm__MyArrayFunc1__1 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7781)
			{ "MyArrayFunc2", slm__MyArrayFunc2__1 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7781)
			{ "MyFunc1", slm__MyFunc1__2 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7781)
			{ "MyFunc2", slm__MyFunc2__2 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7781)
			{ "RawFunc", slm__RawFunc__0 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7781)
			{ "ShowMessage", slm__ShowMessage__1 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7781)
			{ "ToStickTestDlg", slm__ToStickTestDlg__1 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7792)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7867)
	// Register the constants in the static class ''
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7891)
		int& _var_1_1 = (int&)::HIJ;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7914)
		__int64 _var_1_2;
		Sticklib::T_to_U<__int64,int>(_var_1_2, _var_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7972)
		Sticklib::set_lvalue_to_table<__int64>(L, "HIJ", _var_1_2, false);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7891)
		::X::B*& _var_2_1 = (::X::B*&)::XXBB;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7972)
		Sticklib::set_lvalue_to_table<::X::B*>(L, "XXBB", _var_2_1, false);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7891)
		char* _var_3_1 = (char*)XXX;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7914)
		std::string _var_3_2;
		Sticklib::T_to_U<std::string, char *>(_var_3_2, _var_3_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7972)
		Sticklib::set_lvalue_to_table<std::string>(L, "XXX", _var_3_2, false);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7762)
	// Register the static class '::X' and its static member functions.
	Sticklib::push_table(L, "X");
	{
		static struct luaL_Reg lm__X__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7781)
			{ "New", clm__X__New__0 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7792)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__X__Static);
	}

	// Register the enumeration in the static class '::X'

	// Register the enumeration in the static class '::X'
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7820)
	Sticklib::push_table(L, "Enum1");
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7837)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7867)
	// Register the constants in the static class '::X'
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7891)
		int& _var_1_1 = (int&)::X::EFG;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7914)
		__int64 _var_1_2;
		Sticklib::T_to_U<__int64,int>(_var_1_2, _var_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7972)
		Sticklib::set_lvalue_to_table<__int64>(L, "EFG", _var_1_2, false);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8004)
	// Register the regular class '::X' and its regular member functions.
	static struct luaL_Reg lm__X__Method[] =
	{
		{ "__gc", lm__X__Destructor },
		{ nullptr, nullptr },
	};
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8050)
	Sticklib::register_class(L, "lm__X__", lm__X__Method, nullptr);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7762)
	// Register the static class '::X::A' and its static member functions.
	Sticklib::push_table(L, "A");
	{
		static struct luaL_Reg lm__X__A__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7781)
			{ "New", clm__X__A__New__1 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7792)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__X__A__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7867)
	// Register the constants in the static class '::X::A'
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7891)
		char*& _var_1_1 = (char*&)::X::A::ABC;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7914)
		std::string _var_1_2;
		Sticklib::T_to_U<std::string, char *>(_var_1_2, _var_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7972)
		Sticklib::set_lvalue_to_table<std::string>(L, "ABC", _var_1_2, false);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7891)
		int& _var_2_1 = (int&)::X::A::EFG;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7914)
		__int64 _var_2_2;
		Sticklib::T_to_U<__int64,int>(_var_2_2, _var_2_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7972)
		Sticklib::set_lvalue_to_table<__int64>(L, "EFG", _var_2_2, false);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8004)
	// Register the regular class '::X::A' and its regular member functions.
	static struct luaL_Reg lm__X__A__Method[] =
	{
		{ "__gc", lm__X__A__Destructor },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8032)
		{ "FuncX", mlm__X__A__FuncX__2 },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8032)
		{ "Get", mlm__X__A__Get__1 },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8032)
		{ "GetSet", mlm__X__A__GetSet__1 },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8032)
		{ "Set", lm__X__A__Set },
		{ nullptr, nullptr },
	};
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8050)
	Sticklib::register_class(L, "lm__X__A__", lm__X__A__Method, nullptr);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8073)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7762)
	// Register the static class '::X::B' and its static member functions.
	Sticklib::push_table(L, "B");
	{
		static struct luaL_Reg lm__X__B__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7781)
			{ "CreateA", slm__X__B__CreateA__1 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7781)
			{ "DeleteA", slm__X__B__DeleteA__1 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7781)
			{ "New", clm__X__B__New__0 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7792)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__X__B__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8004)
	// Register the regular class '::X::B' and its regular member functions.
	static struct luaL_Reg lm__X__B__Method[] =
	{
		{ "__gc", lm__X__B__Destructor },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8032)
		{ "Add1", mlm__X__B__Add1__1 },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8032)
		{ "Add2", mlm__X__B__Add2__2 },
		{ nullptr, nullptr },
	};
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8050)
	Sticklib::register_class(L, "lm__X__B__", lm__X__B__Method, nullptr);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8073)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8073)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7762)
	// Register the static class '::NM1' and its static member functions.
	Sticklib::push_table(L, "NM1");
	{
		static struct luaL_Reg lm__NM1__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7781)
			{ "MyFunc2", slm__NM1__MyFunc2__2 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7792)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__NM1__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7762)
	// Register the static class '::NM1::NM1_NM1' and its static member functions.
	Sticklib::push_table(L, "MMM1");
	{
		static struct luaL_Reg lm__NM1__NM1_NM1__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7781)
			{ "MyFunc0", slm__NM1__NM1_NM1__MyFunc0__1 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7781)
			{ "MyFunc1", slm__NM1__NM1_NM1__MyFunc1__2 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7781)
			{ "MyFunc2x", slm__NM1__NM1_NM1__MyFunc2x__1 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7781)
			{ "MyFunc2y", lm__NM1__NM1_NM1__MyFunc2y },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7792)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__NM1__NM1_NM1__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7867)
	// Register the constants in the static class '::NM1::NM1_NM1'
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7891)
		void*& _var_1_1 = (void*&)::NM1::NM1_NM1::ARRAY;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7972)
		Sticklib::set_lvalue_to_table<void*>(L, "ARRAY", _var_1_1, false);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8073)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7762)
	// Register the static class '::NM1::NM1_NM2' and its static member functions.
	Sticklib::push_table(L, "NM1_NM2");
	{
		static struct luaL_Reg lm__NM1__NM1_NM2__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7781)
			{ "New", lm__NM1__NM1_NM2__New },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7792)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__NM1__NM1_NM2__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8004)
	// Register the regular class '::NM1::NM1_NM2' and its regular member functions.
	static struct luaL_Reg lm__NM1__NM1_NM2__Method[] =
	{
		{ "__gc", lm__NM1__NM1_NM2__Destructor },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8032)
		{ "MyFunc2", mlm__NM1__NM1_NM2__MyFunc2__3 },
		{ nullptr, nullptr },
	};
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8050)
	Sticklib::register_class(L, "lm__NM1__NM1_NM2__", lm__NM1__NM1_NM2__Method, nullptr);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8073)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7762)
	// Register the static class '::NM1::NM1_NM3' and its static member functions.
	Sticklib::push_table(L, "NM1_NM3");
	{
		static struct luaL_Reg lm__NM1__NM1_NM3__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7781)
			{ "New", clm__NM1__NM1_NM3__New__0 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7792)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__NM1__NM1_NM3__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8004)
	// Register the regular class '::NM1::NM1_NM3' and its regular member functions.
	static struct luaL_Reg lm__NM1__NM1_NM3__Method[] =
	{
		{ "__gc", lm__NM1__NM1_NM3__Destructor },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8032)
		{ "MyFunc3", lm__NM1__NM1_NM3__MyFunc3 },
		{ nullptr, nullptr },
	};
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8059)
	Sticklib::register_class(L, "lm__NM1__NM1_NM3__", lm__NM1__NM1_NM3__Method, "lm__NM1__NM1_NM2__");

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8073)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8073)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7762)
	// Register the static class '::C' and its static member functions.
	Sticklib::push_table(L, "C");
	{
		static struct luaL_Reg lm__C__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7781)
			{ "New", clm__C__New__0 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7792)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__C__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8004)
	// Register the regular class '::C' and its regular member functions.
	static struct luaL_Reg lm__C__Method[] =
	{
		{ "__gc", lm__C__Destructor },
		{ nullptr, nullptr },
	};
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8059)
	Sticklib::register_class(L, "lm__C__", lm__C__Method, "lm__NM1__NM1_NM3__");

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8073)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7762)
	// Register the static class '::NM2' and its static member functions.
	Sticklib::push_table(L, "NM2");
	{
		static struct luaL_Reg lm__NM2__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7781)
			{ "MyFunc2", slm__NM2__MyFunc2__2 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7792)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__NM2__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8073)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7762)
	// Register the static class '::CStickTestDlg' and its static member functions.
	Sticklib::push_table(L, "CStickTestDlg");
	{
		static struct luaL_Reg lm__CStickTestDlg__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7781)
			{ "New", clm__CStickTestDlg__New__0 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7792)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__CStickTestDlg__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8004)
	// Register the regular class '::CStickTestDlg' and its regular member functions.
	static struct luaL_Reg lm__CStickTestDlg__Method[] =
	{
		{ "__gc", lm__CStickTestDlg__Destructor },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8032)
		{ "DebugOutput", mlm__CStickTestDlg__DebugOutput__2 },
		{ nullptr, nullptr },
	};
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8050)
	Sticklib::register_class(L, "lm__CStickTestDlg__", lm__CStickTestDlg__Method, nullptr);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8073)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8073)
	Sticklib::pop(L);

}

