// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8593)
// Generated by LuaStick, May 27 2021.

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8601)
#include "stdafx.h"
// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8601)
#include "..\..\LuaStick\files\Sticklib.h"
// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8601)
#include "TestClass.h"
// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8601)
#include "StickClassExample.h"
// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8609)
#include "Stick.h"

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5785)
/// <summary>
/// Gets ::TestStruct0 value from Lua stack.
/// </summary>
template<>
void Sticklib::check_lvalue<::TestStruct0>(::TestStruct0 & value, lua_State * L, int arg)
{
	//        stack
	//     :          :
	//     |----------|
	//  arg| table A  |--------------+
	//     |----------|              |
	//     :          :              V
	//                       +--------+--------+
	//                       |  Key   | Value  |
	//                       |--------|--------|
	//                       :        :        :
	//                       |--------|--------|
	//                       | "var1" | value1 |
	//                       |--------|--------|
	//                       :        :        :
	// Premise for following.
	//
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5598)
		//
		// lua_getfield(L, arg, "var1");
		//
		//        stack
		//     +----------+
		//   -1|  value1  |
		//     |----------|
		//     :          :
		//     |----------|
		//     | table A  |--------------+
		//     |----------|              |
		//     :          :              V
		//                       +--------+--------+
		//                       |  Key   | Value  |
		//                       |--------|--------|
		//                       :        :        :
		//                       |--------|--------|
		//                       | "var1" | value1 | ----> Push this value on stack
		//                       |--------|--------|
		//                       :        :        :
		//
		lua_getfield(L, arg, "m_a");

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5649)
		//
		// Sticklib::check_lvalue<__int64>(_argin_1, L, -1);
		//
		//        stack
		//     +----------+
		//   -1|  value1  | ---> Set this value to '_argin_1'
		//     |----------|
		//     :          :
		//     |----------|
		//     | table A  |
		//     |----------|
		//     :          :
		//
		__int64 _argin_1;
		Sticklib::check_lvalue<__int64>(_argin_1, L, -1);

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5671)
		Sticklib::T_to_U<int,__int64>(value.m_a, _argin_1);

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5715)
		//
		// lua_pop(L, 1);
		//
		//        stack
		//     :          :
		//     |----------|
		//  arg| table A  |
		//     |----------|
		//     :          :
		//
		lua_pop(L, 1);
	}
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5598)
		//
		// lua_getfield(L, arg, "var1");
		//
		//        stack
		//     +----------+
		//   -1|  value1  |
		//     |----------|
		//     :          :
		//     |----------|
		//     | table A  |--------------+
		//     |----------|              |
		//     :          :              V
		//                       +--------+--------+
		//                       |  Key   | Value  |
		//                       |--------|--------|
		//                       :        :        :
		//                       |--------|--------|
		//                       | "var1" | value1 | ----> Push this value on stack
		//                       |--------|--------|
		//                       :        :        :
		//
		lua_getfield(L, arg, "m_b");

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5649)
		//
		// Sticklib::check_lvalue<std::string>(_argin_1, L, -1);
		//
		//        stack
		//     +----------+
		//   -1|  value1  | ---> Set this value to '_argin_1'
		//     |----------|
		//     :          :
		//     |----------|
		//     | table A  |
		//     |----------|
		//     :          :
		//
		std::string _argin_1;
		Sticklib::check_lvalue<std::string>(_argin_1, L, -1);

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5671)
		Sticklib::T_to_U<std::wstring, std::string>(value.m_b, _argin_1);

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5715)
		//
		// lua_pop(L, 1);
		//
		//        stack
		//     :          :
		//     |----------|
		//  arg| table A  |
		//     |----------|
		//     :          :
		//
		lua_pop(L, 1);
	}
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5598)
		//
		// lua_getfield(L, arg, "var1");
		//
		//        stack
		//     +----------+
		//   -1|  value1  |
		//     |----------|
		//     :          :
		//     |----------|
		//     | table A  |--------------+
		//     |----------|              |
		//     :          :              V
		//                       +--------+--------+
		//                       |  Key   | Value  |
		//                       |--------|--------|
		//                       :        :        :
		//                       |--------|--------|
		//                       | "var1" | value1 | ----> Push this value on stack
		//                       |--------|--------|
		//                       :        :        :
		//
		lua_getfield(L, arg, "m_x");

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5649)
		//
		// Sticklib::check_array<__int64>(_argin_1, L, -1);
		//
		//        stack
		//     +----------+
		//   -1|  value1  | ---> Set this value to '_argin_1'
		//     |----------|
		//     :          :
		//     |----------|
		//     | table A  |
		//     |----------|
		//     :          :
		//
		std::vector<__int64> _argin_1;
		Sticklib::check_array<__int64>(_argin_1, L, -1);

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5671)
		Sticklib::vectorT_to_vectorU<int,__int64>(value.m_x, _argin_1);

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5715)
		//
		// lua_pop(L, 1);
		//
		//        stack
		//     :          :
		//     |----------|
		//  arg| table A  |
		//     |----------|
		//     :          :
		//
		lua_pop(L, 1);
	}
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5598)
		//
		// lua_getfield(L, arg, "var1");
		//
		//        stack
		//     +----------+
		//   -1|  value1  |
		//     |----------|
		//     :          :
		//     |----------|
		//     | table A  |--------------+
		//     |----------|              |
		//     :          :              V
		//                       +--------+--------+
		//                       |  Key   | Value  |
		//                       |--------|--------|
		//                       :        :        :
		//                       |--------|--------|
		//                       | "var1" | value1 | ----> Push this value on stack
		//                       |--------|--------|
		//                       :        :        :
		//
		lua_getfield(L, arg, "x");

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5624)
		//
		// Sticklib::check_lvalue<double>(value.x, L, -1);
		//
		//        stack
		//     +----------+
		//   -1|  value1  | ---> Set this value to 'value.x'
		//     |----------|
		//     :          :
		//     |----------|
		//     | table A  |
		//     |----------|
		//     :          :
		//
		Sticklib::check_lvalue<double>(value.x, L, -1);

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5715)
		//
		// lua_pop(L, 1);
		//
		//        stack
		//     :          :
		//     |----------|
		//  arg| table A  |
		//     |----------|
		//     :          :
		//
		lua_pop(L, 1);
	}
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5752)
/// <summary>
/// Gets ::TestClass0 value from Lua stack.
/// </summary>
template<>
void Sticklib::check_lvalue<::TestClass0*>(::TestClass0 * & value, lua_State * L, int arg)
{
	//        stack
	//     :          :
	//     |----------|            +------------------+
	//  arg| userdata |----------->| allocated memory |
	//     |----------|            +------------------+
	//     :          :
	//                             |------------------|
	//                           sizeof(StickInstanceWrapper)
	//
	// Premise for following.
	//

	// lua_touserdata is valid for userdata and lightuserdata both.
	auto wrapper = (StickInstanceWrapper *)lua_touserdata(L, arg);
	if (!wrapper)
		throw std::invalid_argument("The argument is not userdata nor lightuserdata");
	value = (::TestClass0 *)wrapper->ptr;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5785)
/// <summary>
/// Gets ::TestStruct1 value from Lua stack.
/// </summary>
template<>
void Sticklib::check_lvalue<::TestStruct1>(::TestStruct1 & value, lua_State * L, int arg)
{
	//        stack
	//     :          :
	//     |----------|
	//  arg| table A  |--------------+
	//     |----------|              |
	//     :          :              V
	//                       +--------+--------+
	//                       |  Key   | Value  |
	//                       |--------|--------|
	//                       :        :        :
	//                       |--------|--------|
	//                       | "var1" | value1 |
	//                       |--------|--------|
	//                       :        :        :
	// Premise for following.
	//
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5598)
		//
		// lua_getfield(L, arg, "var1");
		//
		//        stack
		//     +----------+
		//   -1|  value1  |
		//     |----------|
		//     :          :
		//     |----------|
		//     | table A  |--------------+
		//     |----------|              |
		//     :          :              V
		//                       +--------+--------+
		//                       |  Key   | Value  |
		//                       |--------|--------|
		//                       :        :        :
		//                       |--------|--------|
		//                       | "var1" | value1 | ----> Push this value on stack
		//                       |--------|--------|
		//                       :        :        :
		//
		lua_getfield(L, arg, "m_c");

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5624)
		//
		// Sticklib::check_lvalue<::TestStruct0>(value.m_c, L, -1);
		//
		//        stack
		//     +----------+
		//   -1|  value1  | ---> Set this value to 'value.m_c'
		//     |----------|
		//     :          :
		//     |----------|
		//     | table A  |
		//     |----------|
		//     :          :
		//
		Sticklib::check_lvalue<::TestStruct0>(value.m_c, L, -1);

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5715)
		//
		// lua_pop(L, 1);
		//
		//        stack
		//     :          :
		//     |----------|
		//  arg| table A  |
		//     |----------|
		//     :          :
		//
		lua_pop(L, 1);
	}
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5598)
		//
		// lua_getfield(L, arg, "var1");
		//
		//        stack
		//     +----------+
		//   -1|  value1  |
		//     |----------|
		//     :          :
		//     |----------|
		//     | table A  |--------------+
		//     |----------|              |
		//     :          :              V
		//                       +--------+--------+
		//                       |  Key   | Value  |
		//                       |--------|--------|
		//                       :        :        :
		//                       |--------|--------|
		//                       | "var1" | value1 | ----> Push this value on stack
		//                       |--------|--------|
		//                       :        :        :
		//
		lua_getfield(L, arg, "m_d");

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5649)
		//
		// Sticklib::check_lvalue<::TestClass0*>(_argin_1, L, -1);
		//
		//        stack
		//     +----------+
		//   -1|  value1  | ---> Set this value to '_argin_1'
		//     |----------|
		//     :          :
		//     |----------|
		//     | table A  |
		//     |----------|
		//     :          :
		//
		::TestClass0* _argin_1;
		Sticklib::check_lvalue<::TestClass0*>(_argin_1, L, -1);

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5663)
		value.m_d = *_argin_1;

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5715)
		//
		// lua_pop(L, 1);
		//
		//        stack
		//     :          :
		//     |----------|
		//  arg| table A  |
		//     |----------|
		//     :          :
		//
		lua_pop(L, 1);
	}
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5752)
/// <summary>
/// Gets ::TestClass1 value from Lua stack.
/// </summary>
template<>
void Sticklib::check_lvalue<::TestClass1*>(::TestClass1 * & value, lua_State * L, int arg)
{
	//        stack
	//     :          :
	//     |----------|            +------------------+
	//  arg| userdata |----------->| allocated memory |
	//     |----------|            +------------------+
	//     :          :
	//                             |------------------|
	//                           sizeof(StickInstanceWrapper)
	//
	// Premise for following.
	//

	// lua_touserdata is valid for userdata and lightuserdata both.
	auto wrapper = (StickInstanceWrapper *)lua_touserdata(L, arg);
	if (!wrapper)
		throw std::invalid_argument("The argument is not userdata nor lightuserdata");
	value = (::TestClass1 *)wrapper->ptr;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5752)
/// <summary>
/// Gets ::TestClass2 value from Lua stack.
/// </summary>
template<>
void Sticklib::check_lvalue<::TestClass2*>(::TestClass2 * & value, lua_State * L, int arg)
{
	//        stack
	//     :          :
	//     |----------|            +------------------+
	//  arg| userdata |----------->| allocated memory |
	//     |----------|            +------------------+
	//     :          :
	//                             |------------------|
	//                           sizeof(StickInstanceWrapper)
	//
	// Premise for following.
	//

	// lua_touserdata is valid for userdata and lightuserdata both.
	auto wrapper = (StickInstanceWrapper *)lua_touserdata(L, arg);
	if (!wrapper)
		throw std::invalid_argument("The argument is not userdata nor lightuserdata");
	value = (::TestClass2 *)wrapper->ptr;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5752)
/// <summary>
/// Gets ::CStickClassExampleApp value from Lua stack.
/// </summary>
template<>
void Sticklib::check_lvalue<::CStickClassExampleApp*>(::CStickClassExampleApp * & value, lua_State * L, int arg)
{
	//        stack
	//     :          :
	//     |----------|            +------------------+
	//  arg| userdata |----------->| allocated memory |
	//     |----------|            +------------------+
	//     :          :
	//                             |------------------|
	//                           sizeof(StickInstanceWrapper)
	//
	// Premise for following.
	//

	// lua_touserdata is valid for userdata and lightuserdata both.
	auto wrapper = (StickInstanceWrapper *)lua_touserdata(L, arg);
	if (!wrapper)
		throw std::invalid_argument("The argument is not userdata nor lightuserdata");
	value = (::CStickClassExampleApp *)wrapper->ptr;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6088)
/// <summary>
/// Pushes ::TestStruct0 value on Lua stack.
/// </summary>
template<>
void Sticklib::push_lvalue<::TestStruct0>(lua_State * L, ::TestStruct0 const & value, bool own)
{
	//        stack
	//     :          :
	//     |          | 
	//     :          : 
	//                  
	// Premise for following.
	//

	// lua_newtable(L);
	//
	//        stack
	//     +----------+      +---------+---------+
	//   -1|  TABLE   |----->| Key     | Value   |
	//     |----------|      +---------+---------+
	//     :          : 
	//
	lua_newtable(L);
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5823)
		int& _var_1 = (int&)value.m_a;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5846)
		__int64 _var_2;
		Sticklib::T_to_U<__int64,int>(_var_2, _var_1);

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5971)
		//
		// Sticklib::push_lvalue<__int64>(L, value);
		//
		//        stack  
		//     +----------+
		//   -1|  value   |
		//     +----------+      +---------+---------+
		//   -2|  TABLE   |----->| Key     | Value   |
		//     |----------|      +---------+---------+
		//     :          :
		//
		Sticklib::push_lvalue<__int64>(L, _var_2, false);

		// lua_setfield(L, -2, "var1");
		//
		//        stack  
		//     +----------+      +---------+---------+
		//   -1|  TABLE   |----->| Key     | Value   |
		//     |----------|      +---------+---------+
		//     :          :      | "var1"  |  value  |
		//                       +---------+---------+
		//
		lua_setfield(L, -2, "m_a");
	}
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5823)
		std::wstring& _var_1 = (std::wstring&)value.m_b;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5846)
		std::string _var_2;
		Sticklib::Sticklib::T_to_U<std::string, std::wstring>(_var_2, _var_1);

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5971)
		//
		// Sticklib::push_lvalue<std::string>(L, value);
		//
		//        stack  
		//     +----------+
		//   -1|  value   |
		//     +----------+      +---------+---------+
		//   -2|  TABLE   |----->| Key     | Value   |
		//     |----------|      +---------+---------+
		//     :          :
		//
		Sticklib::push_lvalue<std::string>(L, _var_2, false);

		// lua_setfield(L, -2, "var1");
		//
		//        stack  
		//     +----------+      +---------+---------+
		//   -1|  TABLE   |----->| Key     | Value   |
		//     |----------|      +---------+---------+
		//     :          :      | "var1"  |  value  |
		//                       +---------+---------+
		//
		lua_setfield(L, -2, "m_b");
	}
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5823)
		std::vector<int>& _var_1 = (std::vector<int>&)value.m_x;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5846)
		std::vector<__int64> _var_2;
		Sticklib::vectorT_to_vectorU<__int64,int>(_var_2, _var_1);

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5971)
		//
		// Sticklib::push_array<__int64>(L, value);
		//
		//        stack  
		//     +----------+
		//   -1|  value   |
		//     +----------+      +---------+---------+
		//   -2|  TABLE   |----->| Key     | Value   |
		//     |----------|      +---------+---------+
		//     :          :
		//
		Sticklib::push_array<__int64>(L, _var_2, false);

		// lua_setfield(L, -2, "var1");
		//
		//        stack  
		//     +----------+      +---------+---------+
		//   -1|  TABLE   |----->| Key     | Value   |
		//     |----------|      +---------+---------+
		//     :          :      | "var1"  |  value  |
		//                       +---------+---------+
		//
		lua_setfield(L, -2, "m_x");
	}
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5823)
		double& _var_1 = (double&)value.x;

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5971)
		//
		// Sticklib::push_lvalue<double>(L, value);
		//
		//        stack  
		//     +----------+
		//   -1|  value   |
		//     +----------+      +---------+---------+
		//   -2|  TABLE   |----->| Key     | Value   |
		//     |----------|      +---------+---------+
		//     :          :
		//
		Sticklib::push_lvalue<double>(L, _var_1, false);

		// lua_setfield(L, -2, "var1");
		//
		//        stack  
		//     +----------+      +---------+---------+
		//   -1|  TABLE   |----->| Key     | Value   |
		//     |----------|      +---------+---------+
		//     :          :      | "var1"  |  value  |
		//                       +---------+---------+
		//
		lua_setfield(L, -2, "x");
	}
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6054)
/// <summary>
/// Pushes ::TestClass0 value on Lua stack.
/// </summary>
template<>
void Sticklib::push_lvalue<::TestClass0*>(lua_State * L, ::TestClass0 * const & value, bool own)
{
	//                   Premise.
	//       stack
	//    +---------+
	//  -1|   v1    |
	//    |---------|
	//    :         :
	//

	//       stack
	//    |---------|            +------------------+
	//  -1|userdata |----------->| allocated memory |
	//    |---------|            +------------------+
	//  -2|   v1    |
	//    |---------|            |------------------|
	//    :         :          sizeof(StickInstanceWrapper)
	//
	auto ptr = (StickInstanceWrapper *)lua_newuserdata(L, sizeof(StickInstanceWrapper));
	ptr->own = own;
	ptr->ptr = value;

	//       stack
	//    |---------|
	//  -1|metatable|--------------------------+   +----------------------------------------+
	//    |---------|                          |   |                       registry         |
	//  -2|userdata |---+                      V   V                    +-------+-------+   |
	//    |---------|   |              +----------+--------+            | Key   | Value |   |
	//    |   v1    |   |              |   Key    | Value  |            |-------|-------|   |
	//    |---------|   |              |----------|--------|            |regName| table |---+
	//    :         :   |              |  "__gc"  |c++func1<---+        +---A---+-------+
	//                  |              +----------|--------+   |        :   |   :       :
	//                  |              | "xxxxx"  |c++func2|   |            |
	//                  |              +----------|--------+   |       metatable_name
	//                  |              :          :        :   |
	//                  |                                      |
	//                  |    +------------------+              |
	//                  +--->| allocated memory |        c++ Destructor
	//                       +------------------+
	//
	luaL_getmetatable(L, "lm__TestClass0__");

	//                             metatable
	//       stack              +--------------+   +----------------------------------------+
	//    |---------|           |              |   |                       registry         |
	//  -1|userdata |---+       |              V   V                    +-------+-------+   |
	//    |---------|   |       |      +----------+--------+            | Key   | Value |   |
	//    |   v1    |   |       |      |   Key    | Value  |            |-------|-------|   |
	//    |---------|   |       |      |----------|--------|            |regName| table |---+
	//    :         :   |       |      |  "__gc"  |c++func1<---+        +---A---+-------+
	//                  |       |      +----------|--------+   |        :   |   :       :
	//                  |       |      | "xxxxx"  |c++func2|   |            |
	//                  |       |      +----------|--------+   |       metatable_name
	//                  |       |      :          :        :   |
	//                  |       |                              |
	//                  |    +------------------+              |
	//                  +--->| allocated memory |        c++ Destructor
	//                       +------------------+
	//
	::lua_setmetatable(L, -2);
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6088)
/// <summary>
/// Pushes ::TestStruct1 value on Lua stack.
/// </summary>
template<>
void Sticklib::push_lvalue<::TestStruct1>(lua_State * L, ::TestStruct1 const & value, bool own)
{
	//        stack
	//     :          :
	//     |          | 
	//     :          : 
	//                  
	// Premise for following.
	//

	// lua_newtable(L);
	//
	//        stack
	//     +----------+      +---------+---------+
	//   -1|  TABLE   |----->| Key     | Value   |
	//     |----------|      +---------+---------+
	//     :          : 
	//
	lua_newtable(L);
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5823)
		::TestStruct0& _var_1 = (::TestStruct0&)value.m_c;

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5971)
		//
		// Sticklib::push_lvalue<::TestStruct0>(L, value);
		//
		//        stack  
		//     +----------+
		//   -1|  value   |
		//     +----------+      +---------+---------+
		//   -2|  TABLE   |----->| Key     | Value   |
		//     |----------|      +---------+---------+
		//     :          :
		//
		Sticklib::push_lvalue<::TestStruct0>(L, _var_1, false);

		// lua_setfield(L, -2, "var1");
		//
		//        stack  
		//     +----------+      +---------+---------+
		//   -1|  TABLE   |----->| Key     | Value   |
		//     |----------|      +---------+---------+
		//     :          :      | "var1"  |  value  |
		//                       +---------+---------+
		//
		lua_setfield(L, -2, "m_c");
	}
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5823)
		::TestClass0& _var_1 = (::TestClass0&)value.m_d;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5837)
		::TestClass0* _var_2 = &_var_1;

		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(5971)
		//
		// Sticklib::push_lvalue<::TestClass0*>(L, value);
		//
		//        stack  
		//     +----------+
		//   -1|  value   |
		//     +----------+      +---------+---------+
		//   -2|  TABLE   |----->| Key     | Value   |
		//     |----------|      +---------+---------+
		//     :          :
		//
		Sticklib::push_lvalue<::TestClass0*>(L, _var_2, false);

		// lua_setfield(L, -2, "var1");
		//
		//        stack  
		//     +----------+      +---------+---------+
		//   -1|  TABLE   |----->| Key     | Value   |
		//     |----------|      +---------+---------+
		//     :          :      | "var1"  |  value  |
		//                       +---------+---------+
		//
		lua_setfield(L, -2, "m_d");
	}
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6054)
/// <summary>
/// Pushes ::TestClass1 value on Lua stack.
/// </summary>
template<>
void Sticklib::push_lvalue<::TestClass1*>(lua_State * L, ::TestClass1 * const & value, bool own)
{
	//                   Premise.
	//       stack
	//    +---------+
	//  -1|   v1    |
	//    |---------|
	//    :         :
	//

	//       stack
	//    |---------|            +------------------+
	//  -1|userdata |----------->| allocated memory |
	//    |---------|            +------------------+
	//  -2|   v1    |
	//    |---------|            |------------------|
	//    :         :          sizeof(StickInstanceWrapper)
	//
	auto ptr = (StickInstanceWrapper *)lua_newuserdata(L, sizeof(StickInstanceWrapper));
	ptr->own = own;
	ptr->ptr = value;

	//       stack
	//    |---------|
	//  -1|metatable|--------------------------+   +----------------------------------------+
	//    |---------|                          |   |                       registry         |
	//  -2|userdata |---+                      V   V                    +-------+-------+   |
	//    |---------|   |              +----------+--------+            | Key   | Value |   |
	//    |   v1    |   |              |   Key    | Value  |            |-------|-------|   |
	//    |---------|   |              |----------|--------|            |regName| table |---+
	//    :         :   |              |  "__gc"  |c++func1<---+        +---A---+-------+
	//                  |              +----------|--------+   |        :   |   :       :
	//                  |              | "xxxxx"  |c++func2|   |            |
	//                  |              +----------|--------+   |       metatable_name
	//                  |              :          :        :   |
	//                  |                                      |
	//                  |    +------------------+              |
	//                  +--->| allocated memory |        c++ Destructor
	//                       +------------------+
	//
	luaL_getmetatable(L, "lm__TestClass1__");

	//                             metatable
	//       stack              +--------------+   +----------------------------------------+
	//    |---------|           |              |   |                       registry         |
	//  -1|userdata |---+       |              V   V                    +-------+-------+   |
	//    |---------|   |       |      +----------+--------+            | Key   | Value |   |
	//    |   v1    |   |       |      |   Key    | Value  |            |-------|-------|   |
	//    |---------|   |       |      |----------|--------|            |regName| table |---+
	//    :         :   |       |      |  "__gc"  |c++func1<---+        +---A---+-------+
	//                  |       |      +----------|--------+   |        :   |   :       :
	//                  |       |      | "xxxxx"  |c++func2|   |            |
	//                  |       |      +----------|--------+   |       metatable_name
	//                  |       |      :          :        :   |
	//                  |       |                              |
	//                  |    +------------------+              |
	//                  +--->| allocated memory |        c++ Destructor
	//                       +------------------+
	//
	::lua_setmetatable(L, -2);
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6054)
/// <summary>
/// Pushes ::TestClass2 value on Lua stack.
/// </summary>
template<>
void Sticklib::push_lvalue<::TestClass2*>(lua_State * L, ::TestClass2 * const & value, bool own)
{
	//                   Premise.
	//       stack
	//    +---------+
	//  -1|   v1    |
	//    |---------|
	//    :         :
	//

	//       stack
	//    |---------|            +------------------+
	//  -1|userdata |----------->| allocated memory |
	//    |---------|            +------------------+
	//  -2|   v1    |
	//    |---------|            |------------------|
	//    :         :          sizeof(StickInstanceWrapper)
	//
	auto ptr = (StickInstanceWrapper *)lua_newuserdata(L, sizeof(StickInstanceWrapper));
	ptr->own = own;
	ptr->ptr = value;

	//       stack
	//    |---------|
	//  -1|metatable|--------------------------+   +----------------------------------------+
	//    |---------|                          |   |                       registry         |
	//  -2|userdata |---+                      V   V                    +-------+-------+   |
	//    |---------|   |              +----------+--------+            | Key   | Value |   |
	//    |   v1    |   |              |   Key    | Value  |            |-------|-------|   |
	//    |---------|   |              |----------|--------|            |regName| table |---+
	//    :         :   |              |  "__gc"  |c++func1<---+        +---A---+-------+
	//                  |              +----------|--------+   |        :   |   :       :
	//                  |              | "xxxxx"  |c++func2|   |            |
	//                  |              +----------|--------+   |       metatable_name
	//                  |              :          :        :   |
	//                  |                                      |
	//                  |    +------------------+              |
	//                  +--->| allocated memory |        c++ Destructor
	//                       +------------------+
	//
	luaL_getmetatable(L, "lm__TestClass2__");

	//                             metatable
	//       stack              +--------------+   +----------------------------------------+
	//    |---------|           |              |   |                       registry         |
	//  -1|userdata |---+       |              V   V                    +-------+-------+   |
	//    |---------|   |       |      +----------+--------+            | Key   | Value |   |
	//    |   v1    |   |       |      |   Key    | Value  |            |-------|-------|   |
	//    |---------|   |       |      |----------|--------|            |regName| table |---+
	//    :         :   |       |      |  "__gc"  |c++func1<---+        +---A---+-------+
	//                  |       |      +----------|--------+   |        :   |   :       :
	//                  |       |      | "xxxxx"  |c++func2|   |            |
	//                  |       |      +----------|--------+   |       metatable_name
	//                  |       |      :          :        :   |
	//                  |       |                              |
	//                  |    +------------------+              |
	//                  +--->| allocated memory |        c++ Destructor
	//                       +------------------+
	//
	::lua_setmetatable(L, -2);
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6054)
/// <summary>
/// Pushes ::CStickClassExampleApp value on Lua stack.
/// </summary>
template<>
void Sticklib::push_lvalue<::CStickClassExampleApp*>(lua_State * L, ::CStickClassExampleApp * const & value, bool own)
{
	//                   Premise.
	//       stack
	//    +---------+
	//  -1|   v1    |
	//    |---------|
	//    :         :
	//

	//       stack
	//    |---------|            +------------------+
	//  -1|userdata |----------->| allocated memory |
	//    |---------|            +------------------+
	//  -2|   v1    |
	//    |---------|            |------------------|
	//    :         :          sizeof(StickInstanceWrapper)
	//
	auto ptr = (StickInstanceWrapper *)lua_newuserdata(L, sizeof(StickInstanceWrapper));
	ptr->own = own;
	ptr->ptr = value;

	//       stack
	//    |---------|
	//  -1|metatable|--------------------------+   +----------------------------------------+
	//    |---------|                          |   |                       registry         |
	//  -2|userdata |---+                      V   V                    +-------+-------+   |
	//    |---------|   |              +----------+--------+            | Key   | Value |   |
	//    |   v1    |   |              |   Key    | Value  |            |-------|-------|   |
	//    |---------|   |              |----------|--------|            |regName| table |---+
	//    :         :   |              |  "__gc"  |c++func1<---+        +---A---+-------+
	//                  |              +----------|--------+   |        :   |   :       :
	//                  |              | "xxxxx"  |c++func2|   |            |
	//                  |              +----------|--------+   |       metatable_name
	//                  |              :          :        :   |
	//                  |                                      |
	//                  |    +------------------+              |
	//                  +--->| allocated memory |        c++ Destructor
	//                       +------------------+
	//
	luaL_getmetatable(L, "lm__CStickClassExampleApp__");

	//                             metatable
	//       stack              +--------------+   +----------------------------------------+
	//    |---------|           |              |   |                       registry         |
	//  -1|userdata |---+       |              V   V                    +-------+-------+   |
	//    |---------|   |       |      +----------+--------+            | Key   | Value |   |
	//    |   v1    |   |       |      |   Key    | Value  |            |-------|-------|   |
	//    |---------|   |       |      |----------|--------|            |regName| table |---+
	//    :         :   |       |      |  "__gc"  |c++func1<---+        +---A---+-------+
	//                  |       |      +----------|--------+   |        :   |   :       :
	//                  |       |      | "xxxxx"  |c++func2|   |            |
	//                  |       |      +----------|--------+   |       metatable_name
	//                  |       |      :          :        :   |
	//                  |       |                              |
	//                  |    +------------------+              |
	//                  +--->| allocated memory |        c++ Destructor
	//                       +------------------+
	//
	::lua_setmetatable(L, -2);
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6148)
/// <summary>
/// ::TestClass0::~TestClass0()
/// </summary>
static int lm__TestClass0__Destructor(lua_State* L)
{
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Get the class object.
		auto __wrapper = (StickInstanceWrapper*)Sticklib::test_classobject(L, 1, "lm__TestClass0__");
		if (__wrapper->own && __wrapper->ptr != nullptr)
		{
			delete (::TestClass0*)__wrapper->ptr;
			__wrapper->ptr = nullptr;
		}
	}
	catch (std::exception & e)
	{
		luaL_error(L, (std::string("C function error:::TestClass0::~TestClass0:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass0::~TestClass0");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6148)
/// <summary>
/// ::TestClass1::~TestClass1()
/// </summary>
static int lm__TestClass1__Destructor(lua_State* L)
{
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Get the class object.
		auto __wrapper = (StickInstanceWrapper*)Sticklib::test_classobject(L, 1, "lm__TestClass1__");
		if (__wrapper->own && __wrapper->ptr != nullptr)
		{
			delete (::TestClass1*)__wrapper->ptr;
			__wrapper->ptr = nullptr;
		}
	}
	catch (std::exception & e)
	{
		luaL_error(L, (std::string("C function error:::TestClass1::~TestClass1:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass1::~TestClass1");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(6148)
/// <summary>
/// ::TestClass2::~TestClass2()
/// </summary>
static int lm__TestClass2__Destructor(lua_State* L)
{
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Get the class object.
		auto __wrapper = (StickInstanceWrapper*)Sticklib::test_classobject(L, 1, "lm__TestClass2__");
		if (__wrapper->own && __wrapper->ptr != nullptr)
		{
			delete (::TestClass2*)__wrapper->ptr;
			__wrapper->ptr = nullptr;
		}
	}
	catch (std::exception & e)
	{
		luaL_error(L, (std::string("C function error:::TestClass2::~TestClass2:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass2::~TestClass2");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::App()
/// </summary>
static int lm__App__0(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 0)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4436)
		// Call the c++ function.
		auto __lstickvar_ret = (::CStickClassExampleApp*)::App();
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<::CStickClassExampleApp*>(L, __lstickvar_ret, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::App:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::App");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::TestSpace::GetA()
/// </summary>
static int lm__TestSpace__GetA__0(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 0)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4436)
		// Call the c++ function.
		auto __lstickvar_ret = (std::string)::TestSpace::GetA();
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<std::string>(L, __lstickvar_ret, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::TestSpace::GetA:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestSpace::GetA");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::TestClassA::Get()
/// </summary>
static int lm__TestClassA__Get__0(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 0)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4436)
		// Call the c++ function.
		auto __lstickvar_ret = (int)::TestClassA::Get();
		__int64 _argout_0_1;
		Sticklib::T_to_U<__int64,int>(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<__int64>(L, _argout_0_1, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::TestClassA::Get:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClassA::Get");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::TestClass0::Get(::TestStruct0& test)
/// </summary>
static int lm__TestClass0__Get__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4252)
		// Get the class object.
		::TestClass0 * __lstickobj;
		Sticklib::check_lvalue<::TestClass0*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		::TestStruct0 test;
		Sticklib::check_lvalue<::TestStruct0>(test, L, 2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4392)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		__lstickobj->Get((::TestStruct0&)test);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<::TestStruct0>(L, test, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::TestClass0::Get:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass0::Get");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::TestClass0::GetArray(std::vector<::TestStruct0>& test)
/// </summary>
static int lm__TestClass0__GetArray__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4252)
		// Get the class object.
		::TestClass0 * __lstickobj;
		Sticklib::check_lvalue<::TestClass0*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		std::vector<::TestStruct0> test;
		Sticklib::check_array<::TestStruct0>(test, L, 2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4392)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		__lstickobj->GetArray((std::vector<::TestStruct0>&)test);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_array<::TestStruct0>(L, test, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::TestClass0::GetArray:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass0::GetArray");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::TestClass0::GetEnumA(::TestClass0::EnumA& ea)
/// </summary>
static int lm__TestClass0__GetEnumA__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4252)
		// Get the class object.
		::TestClass0 * __lstickobj;
		Sticklib::check_lvalue<::TestClass0*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		__int64 _argin_1_1;
		Sticklib::check_lvalue<__int64>(_argin_1_1, L, 2);
		::TestClass0::EnumA ea;
		Sticklib::T_to_U<::TestClass0::EnumA, __int64>(ea, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4392)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		__lstickobj->GetEnumA((::TestClass0::EnumA&)ea);
		__int64 _argout_1_1;
		Sticklib::T_to_U<__int64, ::TestClass0::EnumA>(_argout_1_1, ea);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<__int64>(L, _argout_1_1, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::TestClass0::GetEnumA:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass0::GetEnumA");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::TestClass0::GetMap(std::map<int,int>& v)
/// </summary>
static int lm__TestClass0__GetMap__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4252)
		// Get the class object.
		::TestClass0 * __lstickobj;
		Sticklib::check_lvalue<::TestClass0*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4374)
		std::map<int,int> v;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4392)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		__lstickobj->GetMap((std::map<int,int>&)v);
		std::unordered_map<__int64,__int64> _argout_1_1;
		MapToUmap(_argout_1_1, v);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_hash<__int64,__int64>(L, _argout_1_1, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::TestClass0::GetMap:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass0::GetMap");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::TestClass0::GetSet(std::set<int>& v)
/// </summary>
static int lm__TestClass0__GetSet__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4252)
		// Get the class object.
		::TestClass0 * __lstickobj;
		Sticklib::check_lvalue<::TestClass0*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4374)
		std::set<int> v;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4392)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		__lstickobj->GetSet((std::set<int>&)v);
		std::vector<__int64> _argout_1_1;
		Sticklib::setT_to_vectorU<__int64, int>(_argout_1_1, v);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_array<__int64>(L, _argout_1_1, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::TestClass0::GetSet:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass0::GetSet");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::TestClass0::GetTitle()
/// </summary>
static int lm__TestClass0__GetTitle__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4252)
		// Get the class object.
		::TestClass0 * __lstickobj;
		Sticklib::check_lvalue<::TestClass0*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4409)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		auto __lstickvar_ret = (std::string&)__lstickobj->GetTitle();
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<std::string>(L, __lstickvar_ret, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::TestClass0::GetTitle:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass0::GetTitle");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::TestClass0::GetUset(std::unordered_set<int>& v)
/// </summary>
static int lm__TestClass0__GetUset__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4252)
		// Get the class object.
		::TestClass0 * __lstickobj;
		Sticklib::check_lvalue<::TestClass0*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4374)
		std::unordered_set<int> v;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4392)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		__lstickobj->GetUset((std::unordered_set<int>&)v);
		std::vector<__int64> _argout_1_1;
		Sticklib::usetT_to_vectorU<__int64, int>(_argout_1_1, v);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_array<__int64>(L, _argout_1_1, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::TestClass0::GetUset:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass0::GetUset");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::TestClass0::GetX()
/// </summary>
static int lm__TestClass0__GetX__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4252)
		// Get the class object.
		::TestClass0 * __lstickobj;
		Sticklib::check_lvalue<::TestClass0*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4409)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		auto __lstickvar_ret = (int)__lstickobj->GetX();
		__int64 _argout_0_1;
		Sticklib::T_to_U<__int64,int>(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<__int64>(L, _argout_0_1, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::TestClass0::GetX:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass0::GetX");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::TestClass0::SetMap(std::map<int,int>& v)
/// </summary>
static int lm__TestClass0__SetMap__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4252)
		// Get the class object.
		::TestClass0 * __lstickobj;
		Sticklib::check_lvalue<::TestClass0*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		std::unordered_map<__int64,__int64> _argin_1_1;
		Sticklib::check_hash<__int64,__int64>(_argin_1_1, L, 2);
		std::map<int,int> v;
		UmapToMap(v, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4392)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		__lstickobj->SetMap((const std::map<int,int>&)v);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::TestClass0::SetMap:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass0::SetMap");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::TestClass0::SetSet(std::set<int>& v)
/// </summary>
static int lm__TestClass0__SetSet__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4252)
		// Get the class object.
		::TestClass0 * __lstickobj;
		Sticklib::check_lvalue<::TestClass0*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		std::vector<__int64> _argin_1_1;
		Sticklib::check_array<__int64>(_argin_1_1, L, 2);
		std::set<int> v;
		Sticklib::vectorT_to_setU<int, __int64>(v, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4392)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		__lstickobj->SetSet((const std::set<int>&)v);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::TestClass0::SetSet:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass0::SetSet");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::TestClass0::SetTitle(std::string& title)
/// </summary>
static int lm__TestClass0__SetTitle__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4252)
		// Get the class object.
		::TestClass0 * __lstickobj;
		Sticklib::check_lvalue<::TestClass0*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		std::string title;
		Sticklib::check_lvalue<std::string>(title, L, 2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4392)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		__lstickobj->SetTitle((const std::string&)title);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::TestClass0::SetTitle:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass0::SetTitle");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::TestClass0::SetUset(std::unordered_set<int>& v)
/// </summary>
static int lm__TestClass0__SetUset__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4252)
		// Get the class object.
		::TestClass0 * __lstickobj;
		Sticklib::check_lvalue<::TestClass0*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		std::vector<__int64> _argin_1_1;
		Sticklib::check_array<__int64>(_argin_1_1, L, 2);
		std::unordered_set<int> v;
		Sticklib::vectorT_to_usetU<int, __int64>(v, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4392)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		__lstickobj->SetUset((const std::unordered_set<int>&)v);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::TestClass0::SetUset:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass0::SetUset");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::TestClass0::Create0()
/// </summary>
static int lm__TestClass0__Create0__0(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 0)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4436)
		// Call the c++ function.
		auto __lstickvar_ret = (TC0*)::TestClass0::Create0();
		::TestClass0* _argout_0_1;
		Sticklib::T_to_U<::TestClass0*, TC0*>(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<::TestClass0*>(L, _argout_0_1, true);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::TestClass0::Create0:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass0::Create0");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::TestClass0::TestClass0()
/// </summary>
static int lm__TestClass0__New__0(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 0)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4446)
		// Create the class object and give back it to lua.
		auto obj = new ::TestClass0();
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4476)
		Sticklib::push_lvalue<::TestClass0*>(L, obj, true);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::TestClass0::TestClass0:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass0::TestClass0");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::TestClass1::Get()
/// </summary>
static int lm__TestClass1__Get__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4252)
		// Get the class object.
		::TestClass1 * __lstickobj;
		Sticklib::check_lvalue<::TestClass1*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4409)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		auto __lstickvar_ret = (int)__lstickobj->Get();
		__int64 _argout_0_1;
		Sticklib::T_to_U<__int64,int>(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<__int64>(L, _argout_0_1, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::TestClass1::Get:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass1::Get");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::TestClass1::GetClass0Array(std::vector<::TestClass0*>& array)
/// </summary>
static int lm__TestClass1__GetClass0Array__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4252)
		// Get the class object.
		::TestClass1 * __lstickobj;
		Sticklib::check_lvalue<::TestClass1*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4374)
		std::vector<::TestClass0*> array;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4392)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		__lstickobj->GetClass0Array((std::vector<::TestClass0*>&)array);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_array<::TestClass0*>(L, array, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::TestClass1::GetClass0Array:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass1::GetClass0Array");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::TestClass1::GetX()
/// </summary>
static int lm__TestClass1__GetX__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4252)
		// Get the class object.
		::TestClass1 * __lstickobj;
		Sticklib::check_lvalue<::TestClass1*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4409)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		auto __lstickvar_ret = (int)__lstickobj->GetX();
		__int64 _argout_0_1;
		Sticklib::T_to_U<__int64,int>(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<__int64>(L, _argout_0_1, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::TestClass1::GetX:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass1::GetX");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::TestClass1::SetClass0Array(std::vector<::TestClass0*>& array)
/// </summary>
static int lm__TestClass1__SetClass0Array__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4252)
		// Get the class object.
		::TestClass1 * __lstickobj;
		Sticklib::check_lvalue<::TestClass1*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		std::vector<::TestClass0*> array;
		Sticklib::check_array<::TestClass0*>(array, L, 2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4392)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		__lstickobj->SetClass0Array((const std::vector<::TestClass0*>&)array);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::TestClass1::SetClass0Array:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass1::SetClass0Array");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::TestClass1::Create1()
/// </summary>
static int lm__TestClass1__Create1__0(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 0)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4436)
		// Call the c++ function.
		auto __lstickvar_ret = (::TestClass1*)::TestClass1::Create1();
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<::TestClass1*>(L, __lstickvar_ret, true);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::TestClass1::Create1:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass1::Create1");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::TestClass1::TestClass1()
/// </summary>
static int lm__TestClass1__New__0(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 0)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4446)
		// Create the class object and give back it to lua.
		auto obj = new ::TestClass1();
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4476)
		Sticklib::push_lvalue<::TestClass1*>(L, obj, true);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::TestClass1::TestClass1:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass1::TestClass1");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::TestClass2::Get2(::TestClass1*& testClass1)
/// </summary>
static int lm__TestClass2__Get2__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4252)
		// Get the class object.
		::TestClass2 * __lstickobj;
		Sticklib::check_lvalue<::TestClass2*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		::TestClass1* testClass1;
		Sticklib::check_lvalue<::TestClass1*>(testClass1, L, 2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4409)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		auto __lstickvar_ret = (int)__lstickobj->Get2((::TestClass1*&)testClass1);
		__int64 _argout_0_1;
		Sticklib::T_to_U<__int64,int>(_argout_0_1, __lstickvar_ret);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<__int64>(L, _argout_0_1, false);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<::TestClass1*>(L, testClass1, false);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::TestClass2::Get2:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass2::Get2");
	}
	return 2;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::TestClass2::Create2(::TestClass2*& testClass2)
/// </summary>
static int lm__TestClass2__Create2__0(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 0)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4374)
		::TestClass2* testClass2;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4422)
		// Call the c++ function.
		::TestClass2::Create2((::TestClass2*&)testClass2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4630)
		Sticklib::push_lvalue<::TestClass2*>(L, testClass2, true);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::TestClass2::Create2:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass2::Create2");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::TestClass2::New(int a)
/// </summary>
static int lm__TestClass2__New__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		__int64 _argin_1_1;
		Sticklib::check_lvalue<__int64>(_argin_1_1, L, 1);
		int a;
		Sticklib::T_to_U<int,__int64>(a, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4446)
		// Create the class object and give back it to lua.
		auto obj = new ::TestClass2((int)a);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4476)
		Sticklib::push_lvalue<::TestClass2*>(L, obj, true);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::TestClass2::New:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::TestClass2::New");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4094)
/// <summary>
/// ::CStickClassExampleApp::Output(wchar_t* message)
/// </summary>
static int lm__CStickClassExampleApp__Output__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4126)
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4252)
		// Get the class object.
		::CStickClassExampleApp * __lstickobj;
		Sticklib::check_lvalue<::CStickClassExampleApp*>(__lstickobj, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4298)
		std::string _argin_1_1;
		Sticklib::check_lvalue<std::string>(_argin_1_1, L, 2);
		std::wstring _argin_1_2;
		Sticklib::T_to_U<std::wstring, std::string>(_argin_1_2, _argin_1_1);
		wchar_t* message;
		Sticklib::T_to_U<wchar_t*,std::wstring>(message, _argin_1_2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4392)
		// Call the c++ function.
		if (__lstickobj == nullptr)
			throw std::invalid_argument("Null pointer is specified as class object.");
		__lstickobj->Output((const wchar_t*)message);
	}
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4712)
		luaL_error(L, (std::string("C function error:::CStickClassExampleApp::Output:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::CStickClassExampleApp::Output");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8730)
/// <summary>
/// LuaStick initializing function.
/// luastick_init must be called to register the classes and its member functions.
/// </summary>
void luastick_init(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7623)
	// Register the global functions.
	Sticklib::push_table(L, "");
	{
		static struct luaL_Reg lm__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7642)
			{ "App", lm__App__0 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7653)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7623)
	// Register the static class '::TestSpace' and its static member functions.
	Sticklib::push_table(L, "TestSpace");
	{
		static struct luaL_Reg lm__TestSpace__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7642)
			{ "GetA", lm__TestSpace__GetA__0 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7653)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__TestSpace__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7934)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7623)
	// Register the static class '::TestClassA' and its static member functions.
	Sticklib::push_table(L, "TestClassA");
	{
		static struct luaL_Reg lm__TestClassA__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7642)
			{ "Get", lm__TestClassA__Get__0 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7653)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__TestClassA__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7934)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7623)
	// Register the static class '::TestClass0' and its static member functions.
	Sticklib::push_table(L, "TestClass0");
	{
		static struct luaL_Reg lm__TestClass0__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7642)
			{ "Create0", lm__TestClass0__Create0__0 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7642)
			{ "New", lm__TestClass0__New__0 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7653)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__TestClass0__Static);
	}

	// Register the enumeration in the static class '::TestClass0'
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7689)
	Sticklib::set_lvalue_to_table<__int64>(L, "J", (__int64)::TestClass0::J, false);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7689)
	Sticklib::set_lvalue_to_table<__int64>(L, "E", (__int64)::TestClass0::E, false);
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7689)
	Sticklib::set_lvalue_to_table<__int64>(L, "F", (__int64)::TestClass0::F, false);
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7689)
	Sticklib::set_lvalue_to_table<__int64>(L, "G", (__int64)::TestClass0::G, false);

	// Register the enumeration in the static class '::TestClass0'
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7681)
	Sticklib::push_table(L, "EnumA");
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7689)
	Sticklib::set_lvalue_to_table<__int64>(L, "AAA", (__int64)::TestClass0::EnumA::A, false);
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7689)
	Sticklib::set_lvalue_to_table<__int64>(L, "C", (__int64)::TestClass0::EnumA::C, false);
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7689)
	Sticklib::set_lvalue_to_table<__int64>(L, "B", (__int64)::TestClass0::EnumA::B, false);
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7698)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7865)
	// Register the regular class '::TestClass0' and its regular member functions.
	static struct luaL_Reg lm__TestClass0__Method[] =
	{
		{ "__gc", lm__TestClass0__Destructor },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7893)
		{ "Get", lm__TestClass0__Get__2 },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7893)
		{ "GetArray", lm__TestClass0__GetArray__2 },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7893)
		{ "GetEnumA", lm__TestClass0__GetEnumA__2 },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7893)
		{ "GetMap", lm__TestClass0__GetMap__1 },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7893)
		{ "GetSet", lm__TestClass0__GetSet__1 },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7893)
		{ "GetTitle", lm__TestClass0__GetTitle__1 },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7893)
		{ "GetUset", lm__TestClass0__GetUset__1 },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7893)
		{ "GetX", lm__TestClass0__GetX__1 },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7893)
		{ "SetMap", lm__TestClass0__SetMap__2 },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7893)
		{ "SetSet", lm__TestClass0__SetSet__2 },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7893)
		{ "SetTitle", lm__TestClass0__SetTitle__2 },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7893)
		{ "SetUset", lm__TestClass0__SetUset__2 },
		{ nullptr, nullptr },
	};
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7911)
	Sticklib::register_class(L, "lm__TestClass0__", lm__TestClass0__Method, nullptr);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7934)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7623)
	// Register the static class '::TestClass1' and its static member functions.
	Sticklib::push_table(L, "TestClass1");
	{
		static struct luaL_Reg lm__TestClass1__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7642)
			{ "Create1", lm__TestClass1__Create1__0 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7642)
			{ "New", lm__TestClass1__New__0 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7653)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__TestClass1__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7865)
	// Register the regular class '::TestClass1' and its regular member functions.
	static struct luaL_Reg lm__TestClass1__Method[] =
	{
		{ "__gc", lm__TestClass1__Destructor },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7893)
		{ "Get", lm__TestClass1__Get__1 },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7893)
		{ "GetClass0Array", lm__TestClass1__GetClass0Array__1 },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7893)
		{ "GetX", lm__TestClass1__GetX__1 },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7893)
		{ "SetClass0Array", lm__TestClass1__SetClass0Array__2 },
		{ nullptr, nullptr },
	};
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7920)
	Sticklib::register_class(L, "lm__TestClass1__", lm__TestClass1__Method, "lm__TestClass0__");

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7934)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7623)
	// Register the static class '::TestClass2' and its static member functions.
	Sticklib::push_table(L, "TestClass2");
	{
		static struct luaL_Reg lm__TestClass2__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7642)
			{ "Create2", lm__TestClass2__Create2__0 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7642)
			{ "New", lm__TestClass2__New__1 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7653)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__TestClass2__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7728)
	// Register the constants in the static class '::TestClass2'
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7752)
		::TestClass0& _var_1_1 = (::TestClass0&)::TestClass2::TESTCLASS0;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7766)
		::TestClass0* _var_1_2 = &_var_1_1;
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7833)
		Sticklib::set_lvalue_to_table<::TestClass0*>(L, "TESTCLASS0", _var_1_2, false);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7865)
	// Register the regular class '::TestClass2' and its regular member functions.
	static struct luaL_Reg lm__TestClass2__Method[] =
	{
		{ "__gc", lm__TestClass2__Destructor },
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7893)
		{ "Get2", lm__TestClass2__Get2__2 },
		{ nullptr, nullptr },
	};
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7911)
	Sticklib::register_class(L, "lm__TestClass2__", lm__TestClass2__Method, nullptr);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7934)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7623)
	// Register the static class '::CStickClassExampleApp' and its static member functions.
	Sticklib::push_table(L, "StickClassExampleApp");
	{
		static struct luaL_Reg lm__CStickClassExampleApp__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7653)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__CStickClassExampleApp__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7865)
	// Register the regular class '::CStickClassExampleApp' and its regular member functions.
	static struct luaL_Reg lm__CStickClassExampleApp__Method[] =
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7893)
		{ "Output", lm__CStickClassExampleApp__Output__2 },
		{ nullptr, nullptr },
	};
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7911)
	Sticklib::register_class(L, "lm__CStickClassExampleApp__", lm__CStickClassExampleApp__Method, nullptr);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7934)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7934)
	Sticklib::pop(L);

}

