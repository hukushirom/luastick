// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8773)
// Generated by LuaStick, Jun 11 2021.

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8781)
#include "..\..\LuaStick\files\Sticklib.h"
// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8781)
#include "main.h"
// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8798)
#include "Stick.h"
#include <random>

#define XXH_STATIC_LINKING_ONLY   /* access advanced declarations */
#define XXH_IMPLEMENTATION   /* access definitions */

#include "..\..\LuaStick\files\xxhash.h"

// Validation id for StickInstanceWrapper.
static unsigned __int64 WRAPPER_SEED = 0;

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::myspace::Add(std::string& v1, std::string& v2)
/// </summary>
static int slm__myspace__Add__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		std::string v1;
		Sticklib::check_lvalue<std::string>(v1, L, 1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		std::string v2;
		Sticklib::check_lvalue<std::string>(v2, L, 2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4533)
		// Call the c++ function.
		auto __lstickvar_ret = (std::string)::myspace::Add((const std::string&)v1, (std::string const&)v2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4740)
		Sticklib::push_lvalue<std::string>(L, __lstickvar_ret, false);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::myspace::Add:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::myspace::Add");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::myspace::ArrayAdd(std::vector<std::wstring>& v1, std::wstring& v2)
/// </summary>
static int slm__myspace__ArrayAdd__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		std::vector<std::string> _argin_1_1;
		Sticklib::check_array<std::string>(_argin_1_1, L, 1);
		std::vector<std::wstring> v1;
		Sticklib::vectorT_to_vectorU<std::wstring,std::string>(v1, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		std::string _argin_2_1;
		Sticklib::check_lvalue<std::string>(_argin_2_1, L, 2);
		std::wstring v2;
		Sticklib::T_to_U<std::wstring, std::string>(v2, _argin_2_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4519)
		// Call the c++ function.
		::myspace::ArrayAdd((std::vector<std::wstring>&)v1, (const std::wstring&)v2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4669)
		std::vector<std::string> _argout_1_1;
		Sticklib::vectorT_to_vectorU<std::string,std::wstring>(_argout_1_1, v1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4740)
		Sticklib::push_array<std::string>(L, _argout_1_1, false);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::myspace::ArrayAdd:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::myspace::ArrayAdd");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::myspace::HashAdd(std::map<std::wstring,int>& v1, int v2)
/// </summary>
static int slm__myspace__HashAdd__2(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 2)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		std::unordered_map<std::string,__int64> _argin_1_1;
		Sticklib::check_hash<std::string,__int64>(_argin_1_1, L, 1);
		std::map<std::string,__int64> _argin_1_2;
		myconv::uomap_to_map(_argin_1_2, _argin_1_1);
		std::map<std::wstring,int> v1;
		myconv::map_to_map<std::wstring,int,std::string,__int64>(v1, _argin_1_2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		__int64 _argin_2_1;
		Sticklib::check_lvalue<__int64>(_argin_2_1, L, 2);
		int v2;
		Sticklib::T_to_U<int,__int64>(v2, _argin_2_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4519)
		// Call the c++ function.
		::myspace::HashAdd((std::map<std::wstring,int>&)v1, (int)v2);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4669)
		std::map<std::string,__int64> _argout_1_1;
		myconv::map_to_map<std::string,__int64,std::wstring,int>(_argout_1_1, v1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4669)
		std::unordered_map<std::string,__int64> _argout_1_2;
		myconv::map_to_uomap(_argout_1_2, _argout_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4740)
		Sticklib::push_hash<std::string,__int64>(L, _argout_1_2, false);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::myspace::HashAdd:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::myspace::HashAdd");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4150)
/// <summary>
/// ::myspace::Print(char* message)
/// </summary>
static int slm__myspace__Print__1(lua_State* L)
{
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4200)
	try
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4210)
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4384)
		std::string _argin_1_1;
		Sticklib::check_lvalue<std::string>(_argin_1_1, L, 1);
		char* message;
		Sticklib::T_to_U<char *, std::string>(message, _argin_1_1);
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4519)
		// Call the c++ function.
		::myspace::Print((char const*)message);
	}
	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
	catch (std::exception & e)
	{
		// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(4836)
		luaL_error(L, (std::string("C function error:::myspace::Print:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:::myspace::Print");
	}
	return 0;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8997)
/// <summary>
/// STICK::ObjectToUserdata(obj)
/// </summary>
static int lm__STICK__ObjectToUserdata__1(lua_State* L)
{
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		auto wrapper = (StickInstanceWrapper *)lua_touserdata(L, 1);
		if (!wrapper)
			throw std::invalid_argument("The argument is not userdata nor lightuserdata");
		if (wrapper->hash != XXH64(&wrapper->ptr, sizeof(wrapper->ptr), WRAPPER_SEED))
			throw std::invalid_argument("Invalid class object");
		Sticklib::push_lvalue<void *>(L, wrapper->ptr, false);
	}
	catch (std::exception & e)
	{
		luaL_error(L, (std::string("C function error:STICK::ObjectToUserdata:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:STICK::ObjectToUserdata");
	}
	return 1;
}

// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8997)
/// <summary>
/// STICK::IsNullObject(obj)
/// </summary>
static int lm__STICK__IsNullObject__1(lua_State* L)
{
	try
	{
		// Check the count of arguments.
		if (lua_gettop(L) != 1)
			throw std::invalid_argument("Count of arguments is not correct.");
		auto wrapper = (StickInstanceWrapper *)lua_touserdata(L, 1);
		if (!wrapper)
			throw std::invalid_argument("The argument is not userdata nor lightuserdata");
		if (wrapper->hash != XXH64(&wrapper->ptr, sizeof(wrapper->ptr), WRAPPER_SEED))
			throw std::invalid_argument("Invalid class object");
		bool isNull = (wrapper->ptr == nullptr);
		Sticklib::push_lvalue<bool>(L, isNull, false);
	}
	catch (std::exception & e)
	{
		luaL_error(L, (std::string("C function error:STICK::IsNullObject:") + e.what()).c_str());
	}
	catch (...)
	{
		luaL_error(L, "C function error:STICK::IsNullObject");
	}
	return 1;
}

/// <summary>
/// LuaStick initializing function.
/// luastick_init must be called to register the classes and its member functions.
/// </summary>
void luastick_init(lua_State* L)
{
	std::random_device seed_gen;
	std::mt19937 engine(seed_gen());
	// Validation id for StickInstanceWrapper.
	WRAPPER_SEED = ((unsigned __int64)engine() << 32) | (unsigned __int64)engine();

	// Register the default namespace '::STICK' and its static member functions.
	Sticklib::push_table(L, "");
	Sticklib::push_table(L, "STICK");
	{
		static struct luaL_Reg lm__STICK__Static[] =
		{
			{ "ObjectToUserdata", lm__STICK__ObjectToUserdata__1 },
			{ "IsNullObject", lm__STICK__IsNullObject__1 },
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__STICK__Static);
	}
	Sticklib::pop(L);
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7762)
	// Register the global functions.
	Sticklib::push_table(L, "");
	{
		static struct luaL_Reg lm__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7792)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7762)
	// Register the static class '::myspace' and its static member functions.
	Sticklib::push_table(L, "myspace");
	{
		static struct luaL_Reg lm__myspace__Static[] =
		{
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7781)
			{ "Add", slm__myspace__Add__2 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7781)
			{ "ArrayAdd", slm__myspace__ArrayAdd__2 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7781)
			{ "HashAdd", slm__myspace__HashAdd__2 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7781)
			{ "Print", slm__myspace__Print__1 },
			// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(7792)
			{ nullptr, nullptr },
		};
		Sticklib::set_functions(L, lm__myspace__Static);
	}

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8073)
	Sticklib::pop(L);

	// Generated at "c:\src\lua\luastick\luastick\src\luastick.cpp"(8073)
	Sticklib::pop(L);

}

